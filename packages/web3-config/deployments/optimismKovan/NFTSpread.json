{
  "address": "0xD56213aB9740e195F2b9f5FaFB5f324466c34edC",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract ISuperfluid",
          "name": "_host",
          "type": "address"
        },
        {
          "internalType": "contract ISuperToken",
          "name": "_spreaderToken",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "INDEX_ID",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "subscriber",
          "type": "address"
        }
      ],
      "name": "deleteShares",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "distribute",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "subscriber",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "units",
          "type": "uint256"
        }
      ],
      "name": "gainShare",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "idaV1",
      "outputs": [
        {
          "internalType": "contract ISuperfluid",
          "name": "host",
          "type": "address"
        },
        {
          "internalType": "contract IInstantDistributionAgreementV1",
          "name": "ida",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "subscriber",
          "type": "address"
        }
      ],
      "name": "loseShare",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "spreaderToken",
      "outputs": [
        {
          "internalType": "contract ISuperToken",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x3a1ce056e78f1fbf3185ddc20bbda6cde5480a285ac51e8ba003db5ffeb831c1",
  "receipt": {
    "to": null,
    "from": "0xA4B7CEe8409673624EC9B075f5A4f9b8EbAdEd49",
    "contractAddress": "0xD56213aB9740e195F2b9f5FaFB5f324466c34edC",
    "transactionIndex": 0,
    "gasUsed": "1556457",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000800000000000080000080000010000000000000000000000000000000000000000000000000000000000000000000000000021000000000000000000200000020000000000000100000800000000000000400000000000000000000000000000000000000000000000000000000002400000000000000000400000000020000000000000000000000000000000000000000100001400000000004000000000000020000000000000000000000000000000000100000000000020000020000000000000000000000000000000000000000000004000000000000000",
    "blockHash": "0x27ed6d326712c2eb2cb27a53e0d4fcf88a34e1d9124ead8fe3b9a996153445b5",
    "transactionHash": "0x3a1ce056e78f1fbf3185ddc20bbda6cde5480a285ac51e8ba003db5ffeb831c1",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 6411568,
        "transactionHash": "0x3a1ce056e78f1fbf3185ddc20bbda6cde5480a285ac51e8ba003db5ffeb831c1",
        "address": "0x04d4f73e9DE52a8fEC544087a66BBbA660A35957",
        "topics": [
          "0x770ea40a13a4644573ed785e5c7116890709947918747febc5add46feb531e2d",
          "0x00000000000000000000000098e5e5d915bf79ceef02c72d1bf8f5b26f0bcbaa"
        ],
        "data": "0x6c0fd518957f77b775af3f5ca108da9973a2107c8dfe7e9e248f7856f690d8120000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
        "logIndex": 0,
        "blockHash": "0x27ed6d326712c2eb2cb27a53e0d4fcf88a34e1d9124ead8fe3b9a996153445b5"
      },
      {
        "transactionIndex": 0,
        "blockNumber": 6411568,
        "transactionHash": "0x3a1ce056e78f1fbf3185ddc20bbda6cde5480a285ac51e8ba003db5ffeb831c1",
        "address": "0x98E5E5d915Bf79ceeF02c72D1bf8f5b26f0bcBaA",
        "topics": [
          "0x01ab8663165edfb7390d9e5f75d960a66dacf4f01fa9787e3a731c870d0da921",
          "0x00000000000000000000000004d4f73e9de52a8fec544087a66bbba660a35957",
          "0x000000000000000000000000d56213ab9740e195f2b9f5fafb5f324466c34edc",
          "0x0000000000000000000000000000000000000000000000000000000000000000"
        ],
        "data": "0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000",
        "logIndex": 1,
        "blockHash": "0x27ed6d326712c2eb2cb27a53e0d4fcf88a34e1d9124ead8fe3b9a996153445b5"
      }
    ],
    "blockNumber": 6411568,
    "cumulativeGasUsed": "1556457",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x74b57883f8ce9F2BD330286E884CfD8BB24AC4ED",
    "0x04d4f73e9DE52a8fEC544087a66BBbA660A35957"
  ],
  "numDeployments": 2,
  "solcInputHash": "f1f181a0549f3d42433610169a0972ba",
  "metadata": "{\"compiler\":{\"version\":\"0.8.14+commit.80d49f37\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract ISuperfluid\",\"name\":\"_host\",\"type\":\"address\"},{\"internalType\":\"contract ISuperToken\",\"name\":\"_spreaderToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"INDEX_ID\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"subscriber\",\"type\":\"address\"}],\"name\":\"deleteShares\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"distribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"subscriber\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"units\",\"type\":\"uint256\"}],\"name\":\"gainShare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"idaV1\",\"outputs\":[{\"internalType\":\"contract ISuperfluid\",\"name\":\"host\",\"type\":\"address\"},{\"internalType\":\"contract IInstantDistributionAgreementV1\",\"name\":\"ida\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"subscriber\",\"type\":\"address\"}],\"name\":\"loseShare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"spreaderToken\",\"outputs\":[{\"internalType\":\"contract ISuperToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"deleteShares(address)\":{\"params\":{\"subscriber\":\"subscriber address whose subscription is to be deleted\"}},\"loseShare(address)\":{\"params\":{\"subscriber\":\"subscriber address whose units are to be decremented\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"deleteShares(address)\":{\"notice\":\"allows an account to delete its entire subscription this contract\"},\"distribute(uint256)\":{\"notice\":\"Takes the entire balance of the designated spreaderToken in the contract and distributes it out to unit holders w/ IDA\"},\"loseShare(address)\":{\"notice\":\"lets an account lose a single distribution unit\"},\"spreaderToken()\":{\"notice\":\"Super token to be distributed.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/NFTSpread.sol\":\"NFTSpread\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\",\"keccak256\":\"0x24b04b8aacaaf1a4a0719117b29c9c3647b1f479c5ac2a60f5ff1bb6d839c238\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC777/IERC777.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC777/IERC777.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC777Token standard as defined in the EIP.\\n *\\n * This contract uses the\\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\\n * token holders and recipients react to token movements by using setting implementers\\n * for the associated interfaces in said registry. See {IERC1820Registry} and\\n * {ERC1820Implementer}.\\n */\\ninterface IERC777 {\\n    /**\\n     * @dev Emitted when `amount` tokens are created by `operator` and assigned to `to`.\\n     *\\n     * Note that some additional user `data` and `operatorData` can be logged in the event.\\n     */\\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\\n\\n    /**\\n     * @dev Emitted when `operator` destroys `amount` tokens from `account`.\\n     *\\n     * Note that some additional user `data` and `operatorData` can be logged in the event.\\n     */\\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\\n\\n    /**\\n     * @dev Emitted when `operator` is made operator for `tokenHolder`\\n     */\\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\\n\\n    /**\\n     * @dev Emitted when `operator` is revoked its operator status for `tokenHolder`\\n     */\\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the smallest part of the token that is not divisible. This\\n     * means all token operations (creation, movement and destruction) must have\\n     * amounts that are a multiple of this number.\\n     *\\n     * For most token contracts, this value will equal 1.\\n     */\\n    function granularity() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by an account (`owner`).\\n     */\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * If send or receive hooks are registered for the caller and `recipient`,\\n     * the corresponding functions will be called with `data` and empty\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits a {Sent} event.\\n     *\\n     * Requirements\\n     *\\n     * - the caller must have at least `amount` tokens.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function send(\\n        address recipient,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\\n     * total supply.\\n     *\\n     * If a send hook is registered for the caller, the corresponding function\\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\\n     *\\n     * Emits a {Burned} event.\\n     *\\n     * Requirements\\n     *\\n     * - the caller must have at least `amount` tokens.\\n     */\\n    function burn(uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev Returns true if an account is an operator of `tokenHolder`.\\n     * Operators can send and burn tokens on behalf of their owners. All\\n     * accounts are their own operator.\\n     *\\n     * See {operatorSend} and {operatorBurn}.\\n     */\\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\\n\\n    /**\\n     * @dev Make an account an operator of the caller.\\n     *\\n     * See {isOperatorFor}.\\n     *\\n     * Emits an {AuthorizedOperator} event.\\n     *\\n     * Requirements\\n     *\\n     * - `operator` cannot be calling address.\\n     */\\n    function authorizeOperator(address operator) external;\\n\\n    /**\\n     * @dev Revoke an account's operator status for the caller.\\n     *\\n     * See {isOperatorFor} and {defaultOperators}.\\n     *\\n     * Emits a {RevokedOperator} event.\\n     *\\n     * Requirements\\n     *\\n     * - `operator` cannot be calling address.\\n     */\\n    function revokeOperator(address operator) external;\\n\\n    /**\\n     * @dev Returns the list of default operators. These accounts are operators\\n     * for all token holders, even if {authorizeOperator} was never called on\\n     * them.\\n     *\\n     * This list is immutable, but individual holders may revoke these via\\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\\n     */\\n    function defaultOperators() external view returns (address[] memory);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\\n     * be an operator of `sender`.\\n     *\\n     * If send or receive hooks are registered for `sender` and `recipient`,\\n     * the corresponding functions will be called with `data` and\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits a {Sent} event.\\n     *\\n     * Requirements\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `sender` must have at least `amount` tokens.\\n     * - the caller must be an operator for `sender`.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function operatorSend(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\\n     * The caller must be an operator of `account`.\\n     *\\n     * If a send hook is registered for `account`, the corresponding function\\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\\n     *\\n     * Emits a {Burned} event.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     * - the caller must be an operator for `account`.\\n     */\\n    function operatorBurn(\\n        address account,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external;\\n\\n    event Sent(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 amount,\\n        bytes data,\\n        bytes operatorData\\n    );\\n}\\n\",\"keccak256\":\"0x093eaf9a4b05adf2bd3730b753f9e1725ed34b80ea4b5f08477ff2f46a188586\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/apps/IDAv1Library.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport {ISuperfluid, ISuperfluidToken} from \\\"../interfaces/superfluid/ISuperfluid.sol\\\";\\n\\nimport {\\n    IInstantDistributionAgreementV1\\n} from \\\"../interfaces/agreements/IInstantDistributionAgreementV1.sol\\\";\\n\\n/// @title Instant Distribution Agreement V1 helper library for solidity development.\\n/// @author Superfluid\\n/// @dev Set a variable of type `InitData` in the contract, then call this library's functions\\n/// directly `initData.functionName()`.\\nlibrary IDAv1Library {\\n\\n    /// @dev Initialization data.\\n    /// @param host Superfluid host contract for calling agreements.\\n    /// @param ida Instant Distribution Agreement contract.\\n    struct InitData {\\n        ISuperfluid host;\\n        IInstantDistributionAgreementV1 ida;\\n    }\\n\\n    /**************************************************************************\\n     * View Functions\\n     *************************************************************************/\\n\\n    /// @dev Gets an index by its ID and publisher.\\n    /// @param idaLibrary Storage pointer to host and ida interfaces.\\n    /// @param token Super token used with the index.\\n    /// @param publisher Publisher of the index.\\n    /// @param indexId ID of the index.\\n    /// @return exist True if the index exists.\\n    /// @return indexValue Total value of the index.\\n    /// @return totalUnitsApproved Units of the index approved by subscribers.\\n    /// @return totalUnitsPending Units of teh index not yet approved by subscribers.\\n    function getIndex(\\n        InitData storage idaLibrary,\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId\\n    )\\n        internal\\n        view\\n        returns (\\n            bool exist,\\n            uint128 indexValue,\\n            uint128 totalUnitsApproved,\\n            uint128 totalUnitsPending\\n        )\\n    {\\n        return idaLibrary.ida.getIndex(token, publisher, indexId);\\n    }\\n\\n    /// @dev Calculates the distribution amount based on the amount of tokens desired to distribute.\\n    /// @param idaLibrary Storage pointer to host and ida interfaces.\\n    /// @param token Super token used with the index.\\n    /// @param publisher Publisher of the index.\\n    /// @param indexId ID of the index.\\n    /// @param amount Amount of tokens desired to distribute.\\n    /// @return actualAmount Amount to be distributed with correct rounding.\\n    /// @return newIndexValue The index value after the distribution would be called.\\n    function calculateDistribution(\\n        InitData storage idaLibrary,\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        uint256 amount\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256 actualAmount,\\n            uint128 newIndexValue\\n        )\\n    {\\n        return idaLibrary.ida.calculateDistribution(token, publisher, indexId, amount);\\n    }\\n\\n    /// @dev List all subscriptions of an address\\n    /// @param idaLibrary Storage pointer to host and ida interfaces.\\n    /// @param token Super token used in the indexes listed.\\n    /// @param subscriber Subscriber address.\\n    /// @return publishers Publishers of the indices.\\n    /// @return indexIds IDs of the indices.\\n    /// @return unitsList Units owned of the indices.\\n    function listSubscriptions(\\n        InitData storage idaLibrary,\\n        ISuperfluidToken token,\\n        address subscriber\\n    )\\n        internal\\n        view\\n        returns (\\n            address[] memory publishers,\\n            uint32[] memory indexIds,\\n            uint128[] memory unitsList\\n        )\\n    {\\n        return idaLibrary.ida.listSubscriptions(token, subscriber);\\n    }\\n\\n    /// @dev Gets subscription by publisher, index id, and subscriber.\\n    /// @param idaLibrary Storage pointer to host and ida interfaces.\\n    /// @param token Super token used with the index.\\n    /// @param publisher Publisher of the index.\\n    /// @param indexId ID of the index.\\n    /// @param subscriber Subscriber to the index.\\n    /// @return exist True if the subscription exists.\\n    /// @return approved True if the subscription has been approved by the subscriber.\\n    /// @return units Units held by the subscriber\\n    /// @return pendingDistribution If not approved, the amount to be claimed on approval.\\n    function getSubscription(\\n        InitData storage idaLibrary,\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber\\n    )\\n        internal\\n        view\\n        returns (\\n            bool exist,\\n            bool approved,\\n            uint128 units,\\n            uint256 pendingDistribution\\n        )\\n    {\\n        return idaLibrary.ida.getSubscription(token, publisher, indexId, subscriber);\\n    }\\n\\n    /// @dev Gets subscription by the agreement ID.\\n    /// @param idaLibrary Storage pointer to host and ida interfaces.\\n    /// @param token Super Token used with the index.\\n    /// @param agreementId Agreement ID, unique to the subscriber and index ID.\\n    /// @return publisher Publisher of the index.\\n    /// @return indexId ID of the index.\\n    /// @return approved True if the subscription has been approved by the subscriber.\\n    /// @return units Units held by the subscriber\\n    /// @return pendingDistribution If not approved, the amount to be claimed on approval.\\n    function getSubscriptionByID(\\n        InitData storage idaLibrary,\\n        ISuperfluidToken token,\\n        bytes32 agreementId\\n    )\\n        internal\\n        view\\n        returns (\\n            address publisher,\\n            uint32 indexId,\\n            bool approved,\\n            uint128 units,\\n            uint256 pendingDistribution\\n        )\\n    {\\n        return idaLibrary.ida.getSubscriptionByID(token, agreementId);\\n    }\\n\\n    /**************************************************************************\\n     * Index Operations\\n     *************************************************************************/\\n\\n    /// @dev Creates a new index.\\n    /// @param idaLibrary Storage pointer to host and ida interfaces.\\n    /// @param token Super Token used with the index.\\n    /// @param indexId ID of the index.\\n    function createIndex(\\n        InitData storage idaLibrary,\\n        ISuperfluidToken token,\\n        uint32 indexId\\n    ) internal {\\n        createIndex(idaLibrary, token, indexId, new bytes(0));\\n    }\\n\\n    /// @dev Creates a new index. This takes arbitrary user data.\\n    /// @param idaLibrary Storage pointer to host and ida interfaces.\\n    /// @param token Super Token used with the index.\\n    /// @param indexId ID of the index.\\n    /// @param userData Arbitrary user data field.\\n    function createIndex(\\n        InitData storage idaLibrary,\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        bytes memory userData\\n    ) internal {\\n        idaLibrary.host.callAgreement(\\n            idaLibrary.ida,\\n            abi.encodeCall(\\n                idaLibrary.ida.createIndex,\\n                (\\n                    token,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n    }\\n\\n    /// @dev Creates a new index in a super app callback.\\n    /// @param idaLibrary Storage pointer to host and ida interfaces.\\n    /// @param ctx Context byte string used by the Superfluid host.\\n    /// @param token Super Token used with the index.\\n    /// @param indexId ID of the index.\\n    function createIndexWithCtx(\\n        InitData storage idaLibrary,\\n        bytes memory ctx,\\n        ISuperfluidToken token,\\n        uint32 indexId\\n    ) internal returns (bytes memory newCtx) {\\n        return createIndexWithCtx(idaLibrary, ctx, token, indexId, new bytes(0));\\n    }\\n\\n    /// @dev Creates a new index in a super app callback. This takes arbitrary user data.\\n    /// @param idaLibrary Storage pointer to host and ida interfaces.\\n    /// @param ctx Context byte string used by the Superfluid host.\\n    /// @param token Super Token used with the index.\\n    /// @param indexId ID of the index.\\n    /// @param userData Arbitrary user data field.\\n    function createIndexWithCtx(\\n        InitData storage idaLibrary,\\n        bytes memory ctx,\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = idaLibrary.host.callAgreementWithContext(\\n            idaLibrary.ida,\\n            abi.encodeCall(\\n                idaLibrary.ida.createIndex,\\n                (\\n                    token,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData,\\n            ctx\\n        );\\n    }\\n\\n    /// @dev Updates an index value. This distributes an amount of tokens equal to\\n    /// `indexValue - lastIndexValue`. See `distribute` for another way to distribute. This takes\\n    /// arbitrary user data.\\n    /// @param idaLibrary Storage pointer to host and ida interfaces.\\n    /// @param token Super Token used with the index.\\n    /// @param indexId ID of the index.\\n    /// @param indexValue New TOTAL index value, this will equal the total amount distributed.\\n    function updateIndexValue(\\n        InitData storage idaLibrary,\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        uint128 indexValue\\n    ) internal {\\n        updateIndexValue(idaLibrary, token, indexId, indexValue, new bytes(0));\\n    }\\n\\n    /// @dev Updates an index value. This distributes an amount of tokens equal to\\n    /// `indexValue - lastIndexValue`. See `distribute` for another way to distribute.\\n    /// @param idaLibrary Storage pointer to host and ida interfaces.\\n    /// @param token Super Token used with the index.\\n    /// @param indexId ID of the index.\\n    /// @param indexValue New TOTAL index value, this will equal the total amount distributed.\\n    /// @param userData Arbitrary user data field.\\n    function updateIndexValue(\\n        InitData storage idaLibrary,\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        uint128 indexValue,\\n        bytes memory userData\\n    ) internal {\\n        idaLibrary.host.callAgreement(\\n            idaLibrary.ida,\\n            abi.encodeCall(\\n                idaLibrary.ida.updateIndex,\\n                (\\n                    token,\\n                    indexId,\\n                    indexValue,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n    }\\n\\n    /// @dev Updates an index value in a super app callback. This distributes an amount of tokens\\n    /// equal to `indexValue - lastIndexValue`. See `distribute` for another way to distribute.\\n    /// @param idaLibrary Storage pointer to host and ida interfaces.\\n    /// @param ctx Context byte string used by the Superfluid host.\\n    /// @param token Super Token used with the index.\\n    /// @param indexId ID of the index.\\n    /// @param indexValue New TOTAL index value, this will equal the total amount distributed.\\n    function updateIndexValueWithCtx(\\n        InitData storage idaLibrary,\\n        bytes memory ctx,\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        uint128 indexValue\\n    ) internal returns (bytes memory newCtx) {\\n        return updateIndexValueWithCtx(\\n            idaLibrary,\\n            ctx,\\n            token,\\n            indexId,\\n            indexValue,\\n            new bytes(0)\\n        );\\n    }\\n\\n    /// @dev Updates an index value in a super app callback. This distributes an amount of tokens\\n    /// equal to `indexValue - lastIndexValue`. See `distribute` for another way to distribute.\\n    /// This takes arbitrary user data.\\n    /// @param idaLibrary Storage pointer to host and ida interfaces.\\n    /// @param ctx Context byte string used by the Superfluid host.\\n    /// @param token Super Token used with the index.\\n    /// @param indexId ID of the index.\\n    /// @param indexValue New TOTAL index value, this will equal the total amount distributed.\\n    function updateIndexValueWithCtx(\\n        InitData storage idaLibrary,\\n        bytes memory ctx,\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        uint128 indexValue,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = idaLibrary.host.callAgreementWithContext(\\n            idaLibrary.ida,\\n            abi.encodeCall(\\n                idaLibrary.ida.updateIndex,\\n                (\\n                    token,\\n                    indexId,\\n                    indexValue,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData,\\n            ctx\\n        );\\n    }\\n\\n    /// @dev Distributes tokens in a more developer friendly way than `updateIndex`. Instead of\\n    /// passing the new total index value, this function will increase the index value by `amount`.\\n    /// @param idaLibrary Storage pointer to host and ida interfaces.\\n    /// @param token Super Token used with the index.\\n    /// @param indexId ID of the index.\\n    /// @param amount Amount by which the index value should increase.\\n    function distribute(\\n        InitData storage idaLibrary,\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        uint256 amount\\n    ) internal {\\n        distribute(idaLibrary, token, indexId, amount, new bytes(0));\\n    }\\n\\n    /// @dev Distributes tokens in a more developer friendly way than `updateIndex`. Instead of\\n    /// passing the new total index value, this function will increase the index value by `amount`.\\n    /// This takes arbitrary user data.\\n    /// @param idaLibrary Storage pointer to host and ida interfaces.\\n    /// @param token Super Token used with the index.\\n    /// @param indexId ID of the index.\\n    /// @param amount Amount by which the index value should increase.\\n    /// @param userData Arbitrary user data field.\\n    function distribute(\\n        InitData storage idaLibrary,\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        uint256 amount,\\n        bytes memory userData\\n    ) internal {\\n        idaLibrary.host.callAgreement(\\n            idaLibrary.ida,\\n            abi.encodeCall(\\n                idaLibrary.ida.distribute,\\n                (\\n                    token,\\n                    indexId,\\n                    amount,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n    }\\n\\n    /// @dev Distributes tokens in a super app callback. Instead of passing the new total index\\n    /// value, this function will increase the index value by `amount`.\\n    /// @param idaLibrary Storage pointer to host and ida interfaces.\\n    /// @param ctx Context byte string used by the Superfluid host.\\n    /// @param token Super Token used with the index.\\n    /// @param indexId ID of the index.\\n    /// @param amount Amount by which the index value should increase.\\n    function distributeWithCtx(\\n        InitData storage idaLibrary,\\n        bytes memory ctx,\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        uint256 amount\\n    ) internal returns (bytes memory newCtx) {\\n        return distributeWithCtx(idaLibrary, ctx, token, indexId, amount, new bytes(0));\\n    }\\n\\n    /// @dev Distributes tokens in a super app callback. Instead of passing the new total index\\n    /// value, this function will increase the index value by `amount`. This takes arbitrary user\\n    /// data.\\n    /// @param idaLibrary Storage pointer to host and ida interfaces.\\n    /// @param ctx Context byte string used by the Superfluid host.\\n    /// @param token Super Token used with the index.\\n    /// @param indexId ID of the index.\\n    /// @param amount Amount by which the index value should increase.\\n    /// @param userData Arbitrary user data field.\\n    function distributeWithCtx(\\n        InitData storage idaLibrary,\\n        bytes memory ctx,\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        uint256 amount,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = idaLibrary.host.callAgreementWithContext(\\n            idaLibrary.ida,\\n            abi.encodeCall(\\n                idaLibrary.ida.distribute,\\n                (\\n                    token,\\n                    indexId,\\n                    amount,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData,\\n            ctx\\n        );\\n    }\\n\\n    /**************************************************************************\\n     * Subscription Operations\\n     *************************************************************************/\\n\\n    /// @dev Approves a subscription to an index. The subscriber's real time balance will not update\\n    /// until the subscription is approved, but once approved, the balance will be updated with\\n    /// prior distributions.\\n    /// @param idaLibrary Storage pointer to host and ida interfaces.\\n    /// @param token Super Token used with the index.\\n    /// @param publisher Publisher of the index.\\n    /// @param indexId ID of the index.\\n    function approveSubscription(\\n        InitData storage idaLibrary,\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId\\n    ) internal {\\n        approveSubscription(idaLibrary, token, publisher, indexId, new bytes(0));\\n    }\\n\\n    /// @dev Approves a subscription to an index. The subscriber's real time balance will not update\\n    /// until the subscription is approved, but once approved, the balance will be updated with\\n    /// prior distributions.\\n    /// This takes arbitrary user data.\\n    /// @param idaLibrary Storage pointer to host and ida interfaces.\\n    /// @param token Super Token used with the index.\\n    /// @param publisher Publisher of the index.\\n    /// @param indexId ID of the index.\\n    /// @param userData Arbitrary user data field.\\n    function approveSubscription(\\n        InitData storage idaLibrary,\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes memory userData\\n    ) internal {\\n        idaLibrary.host.callAgreement(\\n            idaLibrary.ida,\\n            abi.encodeCall(\\n                idaLibrary.ida.approveSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n    }\\n\\n    /// @dev Approves a subscription to an index in a super app callback. The subscriber's real time\\n    /// balance will not update until the subscription is approved, but once approved, the balance\\n    /// will be updated with prior distributions.\\n    /// @param idaLibrary Storage pointer to host and ida interfaces.\\n    /// @param ctx Context byte string used by the Superfluid host.\\n    /// @param token Super Token used with the index.\\n    /// @param publisher Publisher of the index.\\n    /// @param indexId ID of the index.\\n    function approveSubscriptionWithCtx(\\n        InitData storage idaLibrary,\\n        bytes memory ctx,\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId\\n    ) internal returns (bytes memory newCtx) {\\n        return approveSubscriptionWithCtx(\\n            idaLibrary,\\n            ctx,\\n            token,\\n            publisher,\\n            indexId,\\n            new bytes(0)\\n        );\\n    }\\n\\n    /// @dev Approves a subscription to an index in a super app callback. The subscriber's real time\\n    /// balance will not update until the subscription is approved, but once approved, the balance\\n    /// will be updated with prior distributions. This takes arbitrary user data.\\n    /// @param idaLibrary Storage pointer to host and ida interfaces.\\n    /// @param ctx Context byte string used by the Superfluid host.\\n    /// @param token Super Token used with the index.\\n    /// @param publisher Publisher of the index.\\n    /// @param indexId ID of the index.\\n    /// @param userData Arbitrary user data field.\\n    function approveSubscriptionWithCtx(\\n        InitData storage idaLibrary,\\n        bytes memory ctx,\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = idaLibrary.host.callAgreementWithContext(\\n            idaLibrary.ida,\\n            abi.encodeCall(\\n                idaLibrary.ida.approveSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData,\\n            ctx\\n        );\\n    }\\n\\n    /// @dev Revokes a previously approved subscription.\\n    /// @param idaLibrary Storage pointer to host and ida interfaces.\\n    /// @param token Super Token used with the index.\\n    /// @param publisher Publisher of the index.\\n    /// @param indexId ID of the index.\\n    function revokeSubscription(\\n        InitData storage idaLibrary,\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId\\n    ) internal {\\n        revokeSubscription(idaLibrary, token, publisher, indexId, new bytes(0));\\n    }\\n\\n    /// @dev Revokes a previously approved subscription. This takes arbitrary user data.\\n    /// @param idaLibrary Storage pointer to host and ida interfaces.\\n    /// @param token Super Token used with the index.\\n    /// @param publisher Publisher of the index.\\n    /// @param indexId ID of the index.\\n    /// @param userData Arbitrary user data field.\\n    function revokeSubscription(\\n        InitData storage idaLibrary,\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes memory userData\\n    ) internal {\\n        idaLibrary.host.callAgreement(\\n            idaLibrary.ida,\\n            abi.encodeCall(\\n                idaLibrary.ida.revokeSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n    }\\n\\n    /// @dev Revokes a previously approved subscription in a super app callback.\\n    /// @param idaLibrary Storage pointer to host and ida interfaces.\\n    /// @param ctx Context byte string used by the Superfluid host.\\n    /// @param token Super Token used with the index.\\n    /// @param publisher Publisher of the index.\\n    /// @param indexId ID of the index.\\n    function revokeSubscriptionWithCtx(\\n        InitData storage idaLibrary,\\n        bytes memory ctx,\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId\\n    ) internal returns (bytes memory newCtx) {\\n        return revokeSubscriptionWithCtx(\\n            idaLibrary,\\n            ctx,\\n            token,\\n            publisher,\\n            indexId,\\n            new bytes(0)\\n        );\\n    }\\n\\n    /// @dev Revokes a previously approved subscription in a super app callback. This takes\\n    /// arbitrary user data.\\n    /// @param idaLibrary Storage pointer to host and ida interfaces.\\n    /// @param ctx Context byte string used by the Superfluid host.\\n    /// @param token Super Token used with the index.\\n    /// @param publisher Publisher of the index.\\n    /// @param indexId ID of the index.\\n    /// @param userData Arbitrary user data field.\\n    function revokeSubscriptionWithCtx(\\n        InitData storage idaLibrary,\\n        bytes memory ctx,\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = idaLibrary.host.callAgreementWithContext(\\n            idaLibrary.ida,\\n            abi.encodeCall(\\n                idaLibrary.ida.revokeSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData,\\n            ctx\\n        );\\n    }\\n\\n    /// @dev Updates the units of a subscription. This changes the number of shares the subscriber\\n    /// holds.\\n    /// @param idaLibrary Storage pointer to host and ida interfaces.\\n    /// @param token Super Token used with the index.\\n    /// @param indexId ID of the index.\\n    /// @param subscriber Subscriber address whose units are to be updated.\\n    /// @param units New number of units the subscriber holds.\\n    function updateSubscriptionUnits(\\n        InitData storage idaLibrary,\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        address subscriber,\\n        uint128 units\\n    ) internal {\\n        updateSubscriptionUnits(idaLibrary, token, indexId, subscriber, units, new bytes(0));\\n    }\\n\\n    /// @dev Updates the units of a subscription. This changes the number of shares the subscriber\\n    /// holds. This takes arbitrary user data.\\n    /// @param idaLibrary Storage pointer to host and ida interfaces.\\n    /// @param token Super Token used with the index.\\n    /// @param indexId ID of the index.\\n    /// @param subscriber Subscriber address whose units are to be updated.\\n    /// @param units New number of units the subscriber holds.\\n    /// @param userData Arbitrary user data field.\\n    function updateSubscriptionUnits(\\n        InitData storage idaLibrary,\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        address subscriber,\\n        uint128 units,\\n        bytes memory userData\\n    ) internal {\\n        idaLibrary.host.callAgreement(\\n            idaLibrary.ida,\\n            abi.encodeCall(\\n                idaLibrary.ida.updateSubscription,\\n                (\\n                    token,\\n                    indexId,\\n                    subscriber,\\n                    units,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n    }\\n\\n    /// @dev Updates the units of a subscription in a super app callback. This changes the number of\\n    /// shares the subscriber holds.\\n    /// @param idaLibrary Storage pointer to host and ida interfaces.\\n    /// @param ctx Context byte string used by the Superfluid host.\\n    /// @param token Super Token used with the index.\\n    /// @param indexId ID of the index.\\n    /// @param subscriber Subscriber address whose units are to be updated.\\n    /// @param units New number of units the subscriber holds.\\n    function updateSubscriptionUnitsWithCtx(\\n        InitData storage idaLibrary,\\n        bytes memory ctx,\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        address subscriber,\\n        uint128 units\\n    ) internal returns (bytes memory newCtx) {\\n        return updateSubscriptionUnitsWithCtx(\\n            idaLibrary,\\n            ctx,\\n            token,\\n            indexId,\\n            subscriber,\\n            units,\\n            new bytes(0)\\n        );\\n    }\\n\\n    /// @dev Updates the units of a subscription in a super app callback. This changes the number of\\n    /// shares the subscriber holds. This takes arbitrary user data.\\n    /// @param idaLibrary Storage pointer to host and ida interfaces.\\n    /// @param ctx Context byte string used by the Superfluid host.\\n    /// @param token Super Token used with the index.\\n    /// @param indexId ID of the index.\\n    /// @param subscriber Subscriber address whose units are to be updated.\\n    /// @param units New number of units the subscriber holds.\\n    /// @param userData Arbitrary user data field.\\n    function updateSubscriptionUnitsWithCtx(\\n        InitData storage idaLibrary,\\n        bytes memory ctx,\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        address subscriber,\\n        uint128 units,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = idaLibrary.host.callAgreementWithContext(\\n            idaLibrary.ida,\\n            abi.encodeCall(\\n                idaLibrary.ida.updateSubscription,\\n                (\\n                    token,\\n                    indexId,\\n                    subscriber,\\n                    units,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData,\\n            ctx\\n        );\\n    }\\n\\n    /// @dev Deletes a subscription, setting a subcriber's units to zero.\\n    /// @param idaLibrary Storage pointer to host and ida interfaces.\\n    /// @param token Super Token used with the index.\\n    /// @param publisher Publisher of the index.\\n    /// @param indexId ID of the index.\\n    /// @param subscriber Subscriber address whose units are to be deleted.\\n    function deleteSubscription(\\n        InitData storage idaLibrary,\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber\\n    ) internal {\\n        deleteSubscription(idaLibrary, token, publisher, indexId, subscriber, new bytes(0));\\n    }\\n\\n    /// @dev Deletes a subscription, setting a subcriber's units to zero. This takes arbitrary user\\n    /// data.\\n    /// @param idaLibrary Storage pointer to host and ida interfaces.\\n    /// @param token Super Token used with the index.\\n    /// @param publisher Publisher of the index.\\n    /// @param indexId ID of the index.\\n    /// @param subscriber Subscriber address whose units are to be deleted.\\n    /// @param userData Arbitrary user data field.\\n    function deleteSubscription(\\n        InitData storage idaLibrary,\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes memory userData\\n    ) internal {\\n        idaLibrary.host.callAgreement(\\n            idaLibrary.ida,\\n            abi.encodeCall(\\n                idaLibrary.ida.deleteSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    subscriber,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n    }\\n\\n    /// @dev Deletes a subscription in a super app callback, setting a subcriber's units to zero.\\n    /// @param idaLibrary Storage pointer to host and ida interfaces.\\n    /// @param ctx Context byte string used by the Superfluid host.\\n    /// @param token Super Token used with the index.\\n    /// @param publisher Publisher of the index.\\n    /// @param indexId ID of the index.\\n    /// @param subscriber Subscriber address whose units are to be deleted.\\n    function deleteSubscriptionWithCtx(\\n        InitData storage idaLibrary,\\n        bytes memory ctx,\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber\\n    ) internal returns (bytes memory newCtx) {\\n        return deleteSubscriptionWithCtx(\\n            idaLibrary,\\n            ctx,\\n            token,\\n            publisher,\\n            indexId,\\n            subscriber,\\n            new bytes(0)\\n        );\\n    }\\n\\n    /// @dev Deletes a subscription in a super app callback, setting a subcriber's units to zero.\\n    /// This takes arbitrary user data.\\n    /// @param idaLibrary Storage pointer to host and ida interfaces.\\n    /// @param ctx Context byte string used by the Superfluid host.\\n    /// @param token Super Token used with the index.\\n    /// @param publisher Publisher of the index.\\n    /// @param indexId ID of the index.\\n    /// @param subscriber Subscriber address whose units are to be deleted.\\n    /// @param userData Arbitrary user data field.\\n    function deleteSubscriptionWithCtx(\\n        InitData storage idaLibrary,\\n        bytes memory ctx,\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = idaLibrary.host.callAgreementWithContext(\\n            idaLibrary.ida,\\n            abi.encodeCall(\\n                idaLibrary.ida.deleteSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    subscriber,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData,\\n            ctx\\n        );\\n    }\\n\\n    /// @dev Claims pending distribution. Subscription should not be approved.\\n    /// @param idaLibrary Storage pointer to host and ida interfaces.\\n    /// @param token Super Token used with the index.\\n    /// @param publisher Publisher of the index.\\n    /// @param indexId ID of the index.\\n    /// @param subscriber Subscriber address that receives the claim.\\n    function claim(\\n        InitData storage idaLibrary,\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber\\n    ) internal {\\n        claim(idaLibrary, token, publisher, indexId, subscriber, new bytes(0));\\n    }\\n\\n    /// @dev Claims pending distribution. Subscription should not be approved. This takes arbitrary\\n    /// user data.\\n    /// @param idaLibrary Storage pointer to host and ida interfaces.\\n    /// @param token Super Token used with the index.\\n    /// @param publisher Publisher of the index.\\n    /// @param indexId ID of the index.\\n    /// @param subscriber Subscriber address that receives the claim.\\n    /// @param userData Arbitrary user data field.\\n    function claim(\\n        InitData storage idaLibrary,\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes memory userData\\n    ) internal {\\n        idaLibrary.host.callAgreement(\\n            idaLibrary.ida,\\n            abi.encodeCall(\\n                idaLibrary.ida.claim,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    subscriber,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n    }\\n\\n    /// @dev Claims pending distribution in a super app callback. Subscription should not be\\n    /// approved.\\n    /// @param idaLibrary Storage pointer to host and ida interfaces.\\n    /// @param token Super Token used with the index.\\n    /// @param publisher Publisher of the index.\\n    /// @param indexId ID of the index.\\n    /// @param subscriber Subscriber address that receives the claim.\\n    function claimWithCtx(\\n        InitData storage idaLibrary,\\n        bytes memory ctx,\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber\\n    ) internal returns (bytes memory newCtx) {\\n        return claimWithCtx(\\n            idaLibrary,\\n            ctx,\\n            token,\\n            publisher,\\n            indexId,\\n            subscriber,\\n            new bytes(0)\\n        );\\n    }\\n\\n    /// @dev Claims pending distribution in a super app callback. Subscription should not be\\n    /// approved. This takes arbitrary user data.\\n    /// @param idaLibrary Storage pointer to host and ida interfaces.\\n    /// @param token Super Token used with the index.\\n    /// @param publisher Publisher of the index.\\n    /// @param indexId ID of the index.\\n    /// @param subscriber Subscriber address that receives the claim.\\n    /// @param userData Arbitrary user data field.\\n    function claimWithCtx(\\n        InitData storage idaLibrary,\\n        bytes memory ctx,\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = idaLibrary.host.callAgreementWithContext(\\n            idaLibrary.ida,\\n            abi.encodeCall(\\n                idaLibrary.ida.claim,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    subscriber,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData,\\n            ctx\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x6ea8462f8acd24e4f31aa1e0e78df01d6d47279cebf306ed2844114c06c99fca\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/apps/SuperAppBase.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\n\\nimport {\\n    ISuperfluid,\\n    ISuperToken,\\n    ISuperApp,\\n    SuperAppDefinitions\\n} from \\\"../interfaces/superfluid/ISuperfluid.sol\\\";\\n\\nabstract contract SuperAppBase is ISuperApp {\\n\\n    function beforeAgreementCreated(\\n        ISuperToken /*superToken*/,\\n        address /*agreementClass*/,\\n        bytes32 /*agreementId*/,\\n        bytes calldata /*agreementData*/,\\n        bytes calldata /*ctx*/\\n    )\\n        external\\n        view\\n        virtual\\n        override\\n        returns (bytes memory /*cbdata*/)\\n    {\\n        revert(\\\"Unsupported callback - Before Agreement Created\\\");\\n    }\\n\\n    function afterAgreementCreated(\\n        ISuperToken /*superToken*/,\\n        address /*agreementClass*/,\\n        bytes32 /*agreementId*/,\\n        bytes calldata /*agreementData*/,\\n        bytes calldata /*cbdata*/,\\n        bytes calldata /*ctx*/\\n    )\\n        external\\n        virtual\\n        override\\n        returns (bytes memory /*newCtx*/)\\n    {\\n        revert(\\\"Unsupported callback - After Agreement Created\\\");\\n    }\\n\\n    function beforeAgreementUpdated(\\n        ISuperToken /*superToken*/,\\n        address /*agreementClass*/,\\n        bytes32 /*agreementId*/,\\n        bytes calldata /*agreementData*/,\\n        bytes calldata /*ctx*/\\n    )\\n        external\\n        view\\n        virtual\\n        override\\n        returns (bytes memory /*cbdata*/)\\n    {\\n        revert(\\\"Unsupported callback - Before Agreement updated\\\");\\n    }\\n\\n    function afterAgreementUpdated(\\n        ISuperToken /*superToken*/,\\n        address /*agreementClass*/,\\n        bytes32 /*agreementId*/,\\n        bytes calldata /*agreementData*/,\\n        bytes calldata /*cbdata*/,\\n        bytes calldata /*ctx*/\\n    )\\n        external\\n        virtual\\n        override\\n        returns (bytes memory /*newCtx*/)\\n    {\\n        revert(\\\"Unsupported callback - After Agreement Updated\\\");\\n    }\\n\\n    function beforeAgreementTerminated(\\n        ISuperToken /*superToken*/,\\n        address /*agreementClass*/,\\n        bytes32 /*agreementId*/,\\n        bytes calldata /*agreementData*/,\\n        bytes calldata /*ctx*/\\n    )\\n        external\\n        view\\n        virtual\\n        override\\n        returns (bytes memory /*cbdata*/)\\n    {\\n        revert(\\\"Unsupported callback -  Before Agreement Terminated\\\");\\n    }\\n\\n    function afterAgreementTerminated(\\n        ISuperToken /*superToken*/,\\n        address /*agreementClass*/,\\n        bytes32 /*agreementId*/,\\n        bytes calldata /*agreementData*/,\\n        bytes calldata /*cbdata*/,\\n        bytes calldata /*ctx*/\\n    )\\n        external\\n        virtual\\n        override\\n        returns (bytes memory /*newCtx*/)\\n    {\\n        revert(\\\"Unsupported callback - After Agreement Terminated\\\");\\n    }\\n\\n}\\n\",\"keccak256\":\"0x54003e523c7ed6d3e8b5aa3f7c80617d8ee1155554f31a1bf6e3fc3eeb634fd4\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/IInstantDistributionAgreementV1.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\n\\nimport { ISuperAgreement } from \\\"../superfluid/ISuperAgreement.sol\\\";\\nimport { ISuperfluidToken } from \\\"../superfluid/ISuperfluidToken.sol\\\";\\n\\n\\n/**\\n * @title Instant Distribution Agreement interface\\n * @author Superfluid\\n *\\n * @notice \\n *   - A publisher can create as many as indices as possibly identifiable with `indexId`.\\n *     - `indexId` is deliberately limited to 32 bits, to avoid the chance for sha-3 collision.\\n *       Despite knowing sha-3 collision is only theoretical.\\n *   - A publisher can create a subscription to an index for any subscriber.\\n *   - A subscription consists of:\\n *     - The index it subscribes to.\\n *     - Number of units subscribed.\\n *   - An index consists of:\\n *     - Current value as `uint128 indexValue`.\\n *     - Total units of the approved subscriptions as `uint128 totalUnitsApproved`.\\n *     - Total units of the non approved subscription as `uint128 totalUnitsPending`.\\n *   - A publisher can update an index with a new value that doesn't decrease.\\n *   - A publisher can update a subscription with any number of units.\\n *   - A publisher or a subscriber can delete a subscription and reset its units to zero.\\n *   - A subscriber must approve the index in order to receive distributions from the publisher\\n *     each time the index is updated.\\n *     - The amount distributed is $$\\\\Delta{index} * units$$\\n *   - Distributions to a non approved subscription stays in the publisher's deposit until:\\n *     - the subscriber approves the subscription (side effect),\\n *     - the publisher updates the subscription (side effect),\\n *     - the subscriber deletes the subscription even if it is never approved (side effect),\\n *     - or the subscriber can explicitly claim them.\\n */\\nabstract contract IInstantDistributionAgreementV1 is ISuperAgreement {\\n\\n    /// @dev ISuperAgreement.agreementType implementation\\n    function agreementType() external override pure returns (bytes32) {\\n        return keccak256(\\\"org.superfluid-finance.agreements.InstantDistributionAgreement.v1\\\");\\n    }\\n\\n    /**************************************************************************\\n     * Index operations\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Create a new index for the publisher\\n     * @param token Super token address\\n     * @param indexId Id of the index\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks \\n     * None\\n     */\\n    function createIndex(\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n    /**\\n    * @dev Index created event\\n    * @param token Super token address\\n    * @param publisher Index creator and publisher\\n    * @param indexId The specified indexId of the newly created index\\n    * @param userData The user provided data\\n    */\\n    event IndexCreated(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        bytes userData);\\n\\n    /**\\n     * @dev Query the data of a index\\n     * @param token Super token address\\n     * @param publisher The publisher of the index\\n     * @param indexId Id of the index\\n     * @return exist Does the index exist\\n     * @return indexValue Value of the current index\\n     * @return totalUnitsApproved Total units approved for the index\\n     * @return totalUnitsPending Total units pending approval for the index\\n     */\\n    function getIndex(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId)\\n            external\\n            view\\n            virtual\\n            returns(\\n                bool exist,\\n                uint128 indexValue,\\n                uint128 totalUnitsApproved,\\n                uint128 totalUnitsPending);\\n\\n    /**\\n     * @dev Calculate actual distribution amount\\n     * @param token Super token address\\n     * @param publisher The publisher of the index\\n     * @param indexId Id of the index\\n     * @param amount The amount of tokens desired to be distributed\\n     * @return actualAmount The amount to be distributed after ensuring no rounding errors\\n     * @return newIndexValue The index value given the desired amount of tokens to be distributed\\n     */\\n    function calculateDistribution(\\n       ISuperfluidToken token,\\n       address publisher,\\n       uint32 indexId,\\n       uint256 amount)\\n           external view\\n           virtual\\n           returns(\\n               uint256 actualAmount,\\n               uint128 newIndexValue);\\n\\n    /**\\n     * @dev Update index value of an index\\n     * @param token Super token address\\n     * @param indexId Id of the index\\n     * @param indexValue Value of the index\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks \\n     * None\\n     */\\n    function updateIndex(\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        uint128 indexValue,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n    /**\\n      * @dev Index updated event\\n      * @param token Super token address\\n      * @param publisher Index updater and publisher\\n      * @param indexId The specified indexId of the updated index\\n      * @param oldIndexValue The previous index value\\n      * @param newIndexValue The updated index value\\n      * @param totalUnitsPending The total units pending when the indexValue was updated\\n      * @param totalUnitsApproved The total units approved when the indexValue was updated\\n      * @param userData The user provided data\\n      */\\n    event IndexUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        uint128 oldIndexValue,\\n        uint128 newIndexValue,\\n        uint128 totalUnitsPending,\\n        uint128 totalUnitsApproved,\\n        bytes userData);\\n\\n    /**\\n     * @dev Distribute tokens through the index\\n     * @param token Super token address\\n     * @param indexId Id of the index\\n     * @param amount The amount of tokens desired to be distributed\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:note \\n     * - This is a convenient version of updateIndex. It adds to the index\\n     *   a delta that equals to `amount / totalUnits`\\n     * - The actual amount distributed could be obtained via\\n     *   `calculateDistribution`. This is due to precision error with index\\n     *   value and units data range\\n     *\\n     * @custom:callbacks \\n     * None\\n     */\\n    function distribute(\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        uint256 amount,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n\\n\\n    /**************************************************************************\\n     * Subscription operations\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Approve the subscription of an index\\n     * @param token Super token address\\n     * @param publisher The publisher of the index\\n     * @param indexId Id of the index\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks \\n     * - if subscription exist\\n     *   - AgreementCreated callback to the publisher:\\n     *      - agreementId is for the subscription\\n     * - if subscription does not exist\\n     *   - AgreementUpdated callback to the publisher:\\n     *      - agreementId is for the subscription\\n     */\\n    function approveSubscription(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n    /**\\n      * @dev Index subscribed event\\n      * @param token Super token address\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param subscriber The approved subscriber\\n      * @param userData The user provided data\\n      */\\n    event IndexSubscribed(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        address subscriber,\\n        bytes userData);\\n\\n    /**\\n      * @dev Subscription approved event\\n      * @param token Super token address\\n      * @param subscriber The approved subscriber\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param userData The user provided data\\n      */\\n    event SubscriptionApproved(\\n        ISuperfluidToken indexed token,\\n        address indexed subscriber,\\n        address publisher,\\n        uint32 indexId,\\n        bytes userData);\\n\\n    /**\\n    * @notice Revoke the subscription of an index\\n    * @dev \\\"Unapproves\\\" the subscription and moves approved units to pending\\n    * @param token Super token address\\n    * @param publisher The publisher of the index\\n    * @param indexId Id of the index\\n    * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n    *\\n    * @custom:callbacks \\n    * - AgreementUpdated callback to the publisher:\\n    *    - agreementId is for the subscription\\n    */\\n    function revokeSubscription(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes calldata ctx)\\n         external\\n         virtual\\n         returns(bytes memory newCtx);\\n    /**\\n      * @dev Index unsubscribed event\\n      * @param token Super token address\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param subscriber The unsubscribed subscriber\\n      * @param userData The user provided data\\n      */\\n    event IndexUnsubscribed(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        address subscriber,\\n        bytes userData);\\n    \\n    /**\\n      * @dev Subscription approved event\\n      * @param token Super token address\\n      * @param subscriber The approved subscriber\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param userData The user provided data\\n      */\\n    event SubscriptionRevoked(\\n        ISuperfluidToken indexed token,\\n        address indexed subscriber,\\n        address publisher,\\n        uint32 indexId,\\n        bytes userData);\\n\\n    /**\\n     * @dev Update the nuber of units of a subscription\\n     * @param token Super token address\\n     * @param indexId Id of the index\\n     * @param subscriber The subscriber of the index\\n     * @param units Number of units of the subscription\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks \\n     * - if subscription exist\\n     *   - AgreementCreated callback to the subscriber:\\n     *      - agreementId is for the subscription\\n     * - if subscription does not exist\\n     *   - AgreementUpdated callback to the subscriber:\\n     *      - agreementId is for the subscription\\n     */\\n    function updateSubscription(\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        address subscriber,\\n        uint128 units,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n\\n    /**\\n      * @dev Index units updated event\\n      * @param token Super token address\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param subscriber The subscriber units updated\\n      * @param units The new units amount\\n      * @param userData The user provided data\\n      */\\n    event IndexUnitsUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        address subscriber,\\n        uint128 units,\\n        bytes userData);\\n    \\n    /**\\n      * @dev Subscription units updated event\\n      * @param token Super token address\\n      * @param subscriber The subscriber units updated\\n      * @param indexId The specified indexId\\n      * @param publisher Index publisher\\n      * @param units The new units amount\\n      * @param userData The user provided data\\n      */\\n    event SubscriptionUnitsUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed subscriber,\\n        address publisher,\\n        uint32 indexId,\\n        uint128 units,\\n        bytes userData);\\n\\n    /**\\n     * @dev Get data of a subscription\\n     * @param token Super token address\\n     * @param publisher The publisher of the index\\n     * @param indexId Id of the index\\n     * @param subscriber The subscriber of the index\\n     * @return exist Does the subscription exist?\\n     * @return approved Is the subscription approved?\\n     * @return units Units of the suscription\\n     * @return pendingDistribution Pending amount of tokens to be distributed for unapproved subscription\\n     */\\n    function getSubscription(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber)\\n            external\\n            view\\n            virtual\\n            returns(\\n                bool exist,\\n                bool approved,\\n                uint128 units,\\n                uint256 pendingDistribution\\n            );\\n\\n    /**\\n     * @notice Get data of a subscription by agreement ID\\n     * @dev indexId (agreementId) is the keccak256 hash of encodePacked(\\\"publisher\\\", publisher, indexId)\\n     * @param token Super token address\\n     * @param agreementId The agreement ID\\n     * @return publisher The publisher of the index\\n     * @return indexId Id of the index\\n     * @return approved Is the subscription approved?\\n     * @return units Units of the suscription\\n     * @return pendingDistribution Pending amount of tokens to be distributed for unapproved subscription\\n     */\\n    function getSubscriptionByID(\\n        ISuperfluidToken token,\\n        bytes32 agreementId)\\n            external\\n            view\\n            virtual\\n            returns(\\n                address publisher,\\n                uint32 indexId,\\n                bool approved,\\n                uint128 units,\\n                uint256 pendingDistribution\\n            );\\n\\n    /**\\n     * @dev List subscriptions of an user\\n     * @param token Super token address\\n     * @param subscriber The subscriber's address\\n     * @return publishers Publishers of the subcriptions\\n     * @return indexIds Indexes of the subscriptions\\n     * @return unitsList Units of the subscriptions\\n     */\\n    function listSubscriptions(\\n        ISuperfluidToken token,\\n        address subscriber)\\n            external\\n            view\\n            virtual\\n            returns(\\n                address[] memory publishers,\\n                uint32[] memory indexIds,\\n                uint128[] memory unitsList);\\n\\n    /**\\n     * @dev Delete the subscription of an user\\n     * @param token Super token address\\n     * @param publisher The publisher of the index\\n     * @param indexId Id of the index\\n     * @param subscriber The subscriber's address\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks \\n     * - if the subscriber called it\\n     *   - AgreementTerminated callback to the publsiher:\\n     *      - agreementId is for the subscription\\n     * - if the publisher called it\\n     *   - AgreementTerminated callback to the subscriber:\\n     *      - agreementId is for the subscription\\n     */\\n    function deleteSubscription(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n\\n    /**\\n    * @dev Claim pending distributions\\n    * @param token Super token address\\n    * @param publisher The publisher of the index\\n    * @param indexId Id of the index\\n    * @param subscriber The subscriber's address\\n    * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n    *\\n    * @custom:note The subscription should not be approved yet\\n    *\\n    * @custom:callbacks \\n    * - AgreementUpdated callback to the publisher:\\n    *    - agreementId is for the subscription\\n    */\\n    function claim(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes calldata ctx)\\n        external\\n        virtual\\n        returns(bytes memory newCtx);\\n    \\n    /**\\n      * @dev Index distribution claimed event\\n      * @param token Super token address\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param subscriber The subscriber units updated\\n      * @param amount The pending amount claimed\\n      */\\n    event IndexDistributionClaimed(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        address subscriber,\\n        uint256 amount);\\n    \\n    /**\\n      * @dev Subscription distribution claimed event\\n      * @param token Super token address\\n      * @param subscriber The subscriber units updated\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param amount The pending amount claimed\\n      */\\n    event SubscriptionDistributionClaimed(\\n        ISuperfluidToken indexed token,\\n        address indexed subscriber,\\n        address publisher,\\n        uint32 indexId,\\n        uint256 amount);\\n\\n}\\n\",\"keccak256\":\"0x6ef345136a4f7507d08e657ac3f09539353704a2146b8116d9983878d3113d7e\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/Definitions.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\n\\n/**\\n * @title Super app definitions library\\n * @author Superfluid\\n */\\nlibrary SuperAppDefinitions {\\n\\n    /**************************************************************************\\n    / App manifest config word\\n    /**************************************************************************/\\n\\n    /*\\n     * App level is a way to allow the app to whitelist what other app it can\\n     * interact with (aka. composite app feature).\\n     *\\n     * For more details, refer to the technical paper of superfluid protocol.\\n     */\\n    uint256 constant internal APP_LEVEL_MASK = 0xFF;\\n\\n    // The app is at the final level, hence it doesn't want to interact with any other app\\n    uint256 constant internal APP_LEVEL_FINAL = 1 << 0;\\n\\n    // The app is at the second level, it may interact with other final level apps if whitelisted\\n    uint256 constant internal APP_LEVEL_SECOND = 1 << 1;\\n\\n    function getAppLevel(uint256 configWord) internal pure returns (uint8) {\\n        return uint8(configWord & APP_LEVEL_MASK);\\n    }\\n\\n    uint256 constant internal APP_JAIL_BIT = 1 << 15;\\n    function isAppJailed(uint256 configWord) internal pure returns (bool) {\\n        return (configWord & SuperAppDefinitions.APP_JAIL_BIT) > 0;\\n    }\\n\\n    /**************************************************************************\\n    / Callback implementation bit masks\\n    /**************************************************************************/\\n    uint256 constant internal AGREEMENT_CALLBACK_NOOP_BITMASKS = 0xFF << 32;\\n    uint256 constant internal BEFORE_AGREEMENT_CREATED_NOOP = 1 << (32 + 0);\\n    uint256 constant internal AFTER_AGREEMENT_CREATED_NOOP = 1 << (32 + 1);\\n    uint256 constant internal BEFORE_AGREEMENT_UPDATED_NOOP = 1 << (32 + 2);\\n    uint256 constant internal AFTER_AGREEMENT_UPDATED_NOOP = 1 << (32 + 3);\\n    uint256 constant internal BEFORE_AGREEMENT_TERMINATED_NOOP = 1 << (32 + 4);\\n    uint256 constant internal AFTER_AGREEMENT_TERMINATED_NOOP = 1 << (32 + 5);\\n\\n    /**************************************************************************\\n    / App Jail Reasons\\n    /**************************************************************************/\\n\\n    uint256 constant internal APP_RULE_REGISTRATION_ONLY_IN_CONSTRUCTOR = 1;\\n    uint256 constant internal APP_RULE_NO_REGISTRATION_FOR_EOA = 2;\\n    uint256 constant internal APP_RULE_NO_REVERT_ON_TERMINATION_CALLBACK = 10;\\n    uint256 constant internal APP_RULE_NO_CRITICAL_SENDER_ACCOUNT = 11;\\n    uint256 constant internal APP_RULE_NO_CRITICAL_RECEIVER_ACCOUNT = 12;\\n    uint256 constant internal APP_RULE_CTX_IS_READONLY = 20;\\n    uint256 constant internal APP_RULE_CTX_IS_NOT_CLEAN = 21;\\n    uint256 constant internal APP_RULE_CTX_IS_MALFORMATED = 22;\\n    uint256 constant internal APP_RULE_COMPOSITE_APP_IS_NOT_WHITELISTED = 30;\\n    uint256 constant internal APP_RULE_COMPOSITE_APP_IS_JAILED = 31;\\n    uint256 constant internal APP_RULE_MAX_APP_LEVEL_REACHED = 40;\\n\\n    // Validate configWord cleaness for future compatibility, or else may introduce undefined future behavior\\n    function isConfigWordClean(uint256 configWord) internal pure returns (bool) {\\n        return (configWord & ~(APP_LEVEL_MASK | APP_JAIL_BIT | AGREEMENT_CALLBACK_NOOP_BITMASKS)) == uint256(0);\\n    }\\n}\\n\\n/**\\n * @title Context definitions library\\n * @author Superfluid\\n */\\nlibrary ContextDefinitions {\\n\\n    /**************************************************************************\\n    / Call info\\n    /**************************************************************************/\\n\\n    // app level\\n    uint256 constant internal CALL_INFO_APP_LEVEL_MASK = 0xFF;\\n\\n    // call type\\n    uint256 constant internal CALL_INFO_CALL_TYPE_SHIFT = 32;\\n    uint256 constant internal CALL_INFO_CALL_TYPE_MASK = 0xF << CALL_INFO_CALL_TYPE_SHIFT;\\n    uint8 constant internal CALL_INFO_CALL_TYPE_AGREEMENT = 1;\\n    uint8 constant internal CALL_INFO_CALL_TYPE_APP_ACTION = 2;\\n    uint8 constant internal CALL_INFO_CALL_TYPE_APP_CALLBACK = 3;\\n\\n    function decodeCallInfo(uint256 callInfo)\\n        internal pure\\n        returns (uint8 appLevel, uint8 callType)\\n    {\\n        appLevel = uint8(callInfo & CALL_INFO_APP_LEVEL_MASK);\\n        callType = uint8((callInfo & CALL_INFO_CALL_TYPE_MASK) >> CALL_INFO_CALL_TYPE_SHIFT);\\n    }\\n\\n    function encodeCallInfo(uint8 appLevel, uint8 callType)\\n        internal pure\\n        returns (uint256 callInfo)\\n    {\\n        return uint256(appLevel) | (uint256(callType) << CALL_INFO_CALL_TYPE_SHIFT);\\n    }\\n\\n}\\n\\n/**\\n * @title Flow Operator definitions library\\n  * @author Superfluid\\n */\\n library FlowOperatorDefinitions {\\n    uint8 constant internal AUTHORIZE_FLOW_OPERATOR_CREATE = uint8(1) << 0;\\n    uint8 constant internal AUTHORIZE_FLOW_OPERATOR_UPDATE = uint8(1) << 1;\\n    uint8 constant internal AUTHORIZE_FLOW_OPERATOR_DELETE = uint8(1) << 2;\\n    uint8 constant internal AUTHORIZE_FULL_CONTROL =\\n        AUTHORIZE_FLOW_OPERATOR_CREATE | AUTHORIZE_FLOW_OPERATOR_UPDATE | AUTHORIZE_FLOW_OPERATOR_DELETE;\\n    uint8 constant internal REVOKE_FLOW_OPERATOR_CREATE = ~(uint8(1) << 0);\\n    uint8 constant internal REVOKE_FLOW_OPERATOR_UPDATE = ~(uint8(1) << 1);\\n    uint8 constant internal REVOKE_FLOW_OPERATOR_DELETE = ~(uint8(1) << 2);\\n\\n    function isPermissionsClean(uint8 permissions) internal pure returns (bool) {\\n        return (\\n            permissions & ~(AUTHORIZE_FLOW_OPERATOR_CREATE\\n                | AUTHORIZE_FLOW_OPERATOR_UPDATE\\n                | AUTHORIZE_FLOW_OPERATOR_DELETE)\\n            ) == uint8(0);\\n    }\\n }\\n\\n/**\\n * @title Batch operation library\\n * @author Superfluid\\n */\\nlibrary BatchOperation {\\n    /**\\n     * @dev ERC20.approve batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationApprove(\\n     *     abi.decode(data, (address spender, uint256 amount))\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_ERC20_APPROVE = 1;\\n    /**\\n     * @dev ERC20.transferFrom batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationTransferFrom(\\n     *     abi.decode(data, (address sender, address recipient, uint256 amount)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_ERC20_TRANSFER_FROM = 2;\\n    /**\\n     * @dev SuperToken.upgrade batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationUpgrade(\\n     *     abi.decode(data, (uint256 amount)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERTOKEN_UPGRADE = 1 + 100;\\n    /**\\n     * @dev SuperToken.downgrade batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationDowngrade(\\n     *     abi.decode(data, (uint256 amount)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERTOKEN_DOWNGRADE = 2 + 100;\\n    /**\\n     * @dev Superfluid.callAgreement batch operation type\\n     *\\n     * Call spec:\\n     * callAgreement(\\n     *     ISuperAgreement(target)),\\n     *     abi.decode(data, (bytes calldata, bytes userdata)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERFLUID_CALL_AGREEMENT = 1 + 200;\\n    /**\\n     * @dev Superfluid.callAppAction batch operation type\\n     *\\n     * Call spec:\\n     * callAppAction(\\n     *     ISuperApp(target)),\\n     *     data\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERFLUID_CALL_APP_ACTION = 2 + 200;\\n}\\n\\n/**\\n * @title Superfluid governance configs library\\n * @author Superfluid\\n */\\nlibrary SuperfluidGovernanceConfigs {\\n\\n    bytes32 constant internal SUPERFLUID_REWARD_ADDRESS_CONFIG_KEY =\\n        keccak256(\\\"org.superfluid-finance.superfluid.rewardAddress\\\");\\n    bytes32 constant internal CFAV1_PPP_CONFIG_KEY =\\n        keccak256(\\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1.PPPConfiguration\\\");\\n    bytes32 constant internal SUPERTOKEN_MINIMUM_DEPOSIT_KEY = \\n        keccak256(\\\"org.superfluid-finance.superfluid.superTokenMinimumDeposit\\\");\\n\\n    function getTrustedForwarderConfigKey(address forwarder) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            \\\"org.superfluid-finance.superfluid.trustedForwarder\\\",\\n            forwarder));\\n    }\\n\\n    function getAppRegistrationConfigKey(address deployer, string memory registrationKey) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            \\\"org.superfluid-finance.superfluid.appWhiteListing.registrationKey\\\",\\n            deployer,\\n            registrationKey));\\n    }\\n\\n    function getAppFactoryConfigKey(address factory) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            \\\"org.superfluid-finance.superfluid.appWhiteListing.factory\\\",\\n            factory));\\n    }\\n\\n    function decodePPPConfig(uint256 pppConfig) internal pure returns (uint256 liquidationPeriod, uint256 patricianPeriod) {\\n        liquidationPeriod = (pppConfig >> 32) & type(uint32).max;\\n        patricianPeriod = pppConfig & type(uint32).max;\\n    }\\n}\\n\",\"keccak256\":\"0x199095781e4221b6015d859558da09977f79199f38d342ab4899c2cecdf8cec1\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperAgreement.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\n\\nimport { ISuperfluidToken } from \\\"./ISuperfluidToken.sol\\\";\\n\\n/**\\n * @title Super agreement interface\\n * @author Superfluid\\n */\\ninterface ISuperAgreement {\\n\\n    /**\\n     * @dev Get the type of the agreement class\\n     */\\n    function agreementType() external view returns (bytes32);\\n\\n    /**\\n     * @dev Calculate the real-time balance for the account of this agreement class\\n     * @param account Account the state belongs to\\n     * @param time Time used for the calculation\\n     * @return dynamicBalance Dynamic balance portion of real-time balance of this agreement\\n     * @return deposit Account deposit amount of this agreement\\n     * @return owedDeposit Account owed deposit amount of this agreement\\n     */\\n    function realtimeBalanceOf(\\n        ISuperfluidToken token,\\n        address account,\\n        uint256 time\\n    )\\n        external\\n        view\\n        returns (\\n            int256 dynamicBalance,\\n            uint256 deposit,\\n            uint256 owedDeposit\\n        );\\n\\n}\\n\",\"keccak256\":\"0xc3a6a907245116bcecc70fe4b207454012e8ce4fa190228fb8bbe39e0b1bc5cf\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperApp.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\n\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\n\\n/**\\n * @title SuperApp interface\\n * @author Superfluid\\n * @dev Be aware of the app being jailed, when the word permitted is used.\\n */\\ninterface ISuperApp {\\n\\n    /**\\n     * @dev Callback before a new agreement is created.\\n     * @param superToken The super token used for the agreement.\\n     * @param agreementClass The agreement class address.\\n     * @param agreementId The agreementId\\n     * @param agreementData The agreement data (non-compressed)\\n     * @param ctx The context data.\\n     * @return cbdata A free format in memory data the app can use to pass\\n     *          arbitary information to the after-hook callback.\\n     *\\n     * @custom:note \\n     * - It will be invoked with `staticcall`, no state changes are permitted.\\n     * - Only revert with a \\\"reason\\\" is permitted.\\n     */\\n    function beforeAgreementCreated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata ctx\\n    )\\n        external\\n        view\\n        returns (bytes memory cbdata);\\n\\n    /**\\n     * @dev Callback after a new agreement is created.\\n     * @param superToken The super token used for the agreement.\\n     * @param agreementClass The agreement class address.\\n     * @param agreementId The agreementId\\n     * @param agreementData The agreement data (non-compressed)\\n     * @param cbdata The data returned from the before-hook callback.\\n     * @param ctx The context data.\\n     * @return newCtx The current context of the transaction.\\n     *\\n     * @custom:note \\n     * - State changes is permitted.\\n     * - Only revert with a \\\"reason\\\" is permitted.\\n     */\\n    function afterAgreementCreated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata cbdata,\\n        bytes calldata ctx\\n    )\\n        external\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev Callback before a new agreement is updated.\\n     * @param superToken The super token used for the agreement.\\n     * @param agreementClass The agreement class address.\\n     * @param agreementId The agreementId\\n     * @param agreementData The agreement data (non-compressed)\\n     * @param ctx The context data.\\n     * @return cbdata A free format in memory data the app can use to pass\\n     *          arbitary information to the after-hook callback.\\n     *\\n     * @custom:note \\n     * - It will be invoked with `staticcall`, no state changes are permitted.\\n     * - Only revert with a \\\"reason\\\" is permitted.\\n     */\\n    function beforeAgreementUpdated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata ctx\\n    )\\n        external\\n        view\\n        returns (bytes memory cbdata);\\n\\n\\n    /**\\n    * @dev Callback after a new agreement is updated.\\n    * @param superToken The super token used for the agreement.\\n    * @param agreementClass The agreement class address.\\n    * @param agreementId The agreementId\\n    * @param agreementData The agreement data (non-compressed)\\n    * @param cbdata The data returned from the before-hook callback.\\n    * @param ctx The context data.\\n    * @return newCtx The current context of the transaction.\\n    *\\n    * @custom:note \\n    * - State changes is permitted.\\n    * - Only revert with a \\\"reason\\\" is permitted.\\n    */\\n    function afterAgreementUpdated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata cbdata,\\n        bytes calldata ctx\\n    )\\n        external\\n        returns (bytes memory newCtx);\\n\\n    /**\\n    * @dev Callback before a new agreement is terminated.\\n    * @param superToken The super token used for the agreement.\\n    * @param agreementClass The agreement class address.\\n    * @param agreementId The agreementId\\n    * @param agreementData The agreement data (non-compressed)\\n    * @param ctx The context data.\\n    * @return cbdata A free format in memory data the app can use to pass arbitary information to the after-hook callback.\\n    *\\n    * @custom:note \\n    * - It will be invoked with `staticcall`, no state changes are permitted.\\n    * - Revert is not permitted.\\n    */\\n    function beforeAgreementTerminated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata ctx\\n    )\\n        external\\n        view\\n        returns (bytes memory cbdata);\\n\\n    /**\\n    * @dev Callback after a new agreement is terminated.\\n    * @param superToken The super token used for the agreement.\\n    * @param agreementClass The agreement class address.\\n    * @param agreementId The agreementId\\n    * @param agreementData The agreement data (non-compressed)\\n    * @param cbdata The data returned from the before-hook callback.\\n    * @param ctx The context data.\\n    * @return newCtx The current context of the transaction.\\n    *\\n    * @custom:note \\n    * - State changes is permitted.\\n    * - Revert is not permitted.\\n    */\\n    function afterAgreementTerminated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata cbdata,\\n        bytes calldata ctx\\n    )\\n        external\\n        returns (bytes memory newCtx);\\n}\\n\",\"keccak256\":\"0x42b604992cf67321cc12e8bed16543df0db4eaf125b8c1c82c330ebbeb20c014\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperToken.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\n\\nimport { ISuperfluid } from \\\"./ISuperfluid.sol\\\";\\nimport { ISuperfluidToken } from \\\"./ISuperfluidToken.sol\\\";\\nimport { TokenInfo } from \\\"../tokens/TokenInfo.sol\\\";\\nimport { IERC777 } from \\\"@openzeppelin/contracts/token/ERC777/IERC777.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @title Super token (Superfluid Token + ERC20 + ERC777) interface\\n * @author Superfluid\\n */\\ninterface ISuperToken is ISuperfluidToken, TokenInfo, IERC20, IERC777 {\\n\\n    /**\\n     * @dev Initialize the contract\\n     */\\n    function initialize(\\n        IERC20 underlyingToken,\\n        uint8 underlyingDecimals,\\n        string calldata n,\\n        string calldata s\\n    ) external;\\n\\n    /**************************************************************************\\n    * TokenInfo & ERC777\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view override(IERC777, TokenInfo) returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view override(IERC777, TokenInfo) returns (string memory);\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * @custom:note SuperToken always uses 18 decimals.\\n     *\\n     * This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() external view override(TokenInfo) returns (uint8);\\n\\n    /**************************************************************************\\n    * ERC20 & ERC777\\n    *************************************************************************/\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() external view override(IERC777, IERC20) returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by an account (`owner`).\\n     */\\n    function balanceOf(address account) external view override(IERC777, IERC20) returns(uint256 balance);\\n\\n    /**************************************************************************\\n    * ERC20\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * @return Returns Success a boolean value indicating whether the operation succeeded.\\n     *\\n     * @custom:emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external override(IERC20) returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     *         allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     *         zero by default.\\n     *\\n     * @notice This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external override(IERC20) view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * @return Returns Success a boolean value indicating whether the operation succeeded.\\n     *\\n     * @custom:note Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * @custom:emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external override(IERC20) returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     *         allowance mechanism. `amount` is then deducted from the caller's\\n     *         allowance.\\n     *\\n     * @return Returns Success a boolean value indicating whether the operation succeeded.\\n     *\\n     * @custom:emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external override(IERC20) returns (bool);\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * @custom:emits an {Approval} event indicating the updated allowance.\\n     *\\n     * @custom:requirements \\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * @custom:emits an {Approval} event indicating the updated allowance.\\n     *\\n     * @custom:requirements \\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n     function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n\\n    /**************************************************************************\\n    * ERC777\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Returns the smallest part of the token that is not divisible. This\\n     *         means all token operations (creation, movement and destruction) must have\\n     *         amounts that are a multiple of this number.\\n     *\\n     * @custom:note For super token contracts, this value is always 1\\n     */\\n    function granularity() external view override(IERC777) returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * @dev If send or receive hooks are registered for the caller and `recipient`,\\n     *      the corresponding functions will be called with `data` and empty\\n     *      `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * @custom:emits a {Sent} event.\\n     *\\n     * @custom:requirements \\n     * - the caller must have at least `amount` tokens.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function send(address recipient, uint256 amount, bytes calldata data) external override(IERC777);\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\\n     * total supply.\\n     *\\n     * If a send hook is registered for the caller, the corresponding function\\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\\n     *\\n     * @custom:emits a {Burned} event.\\n     *\\n     * @custom:requirements \\n     * - the caller must have at least `amount` tokens.\\n     */\\n    function burn(uint256 amount, bytes calldata data) external override(IERC777);\\n\\n    /**\\n     * @dev Returns true if an account is an operator of `tokenHolder`.\\n     * Operators can send and burn tokens on behalf of their owners. All\\n     * accounts are their own operator.\\n     *\\n     * See {operatorSend} and {operatorBurn}.\\n     */\\n    function isOperatorFor(address operator, address tokenHolder) external override(IERC777) view returns (bool);\\n\\n    /**\\n     * @dev Make an account an operator of the caller.\\n     *\\n     * See {isOperatorFor}.\\n     *\\n     * @custom:emits an {AuthorizedOperator} event.\\n     *\\n     * @custom:requirements \\n     * - `operator` cannot be calling address.\\n     */\\n    function authorizeOperator(address operator) external override(IERC777);\\n\\n    /**\\n     * @dev Revoke an account's operator status for the caller.\\n     *\\n     * See {isOperatorFor} and {defaultOperators}.\\n     *\\n     * @custom:emits a {RevokedOperator} event.\\n     *\\n     * @custom:requirements \\n     * - `operator` cannot be calling address.\\n     */\\n    function revokeOperator(address operator) external override(IERC777);\\n\\n    /**\\n     * @dev Returns the list of default operators. These accounts are operators\\n     * for all token holders, even if {authorizeOperator} was never called on\\n     * them.\\n     *\\n     * This list is immutable, but individual holders may revoke these via\\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\\n     */\\n    function defaultOperators() external override(IERC777) view returns (address[] memory);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\\n     * be an operator of `sender`.\\n     *\\n     * If send or receive hooks are registered for `sender` and `recipient`,\\n     * the corresponding functions will be called with `data` and\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * @custom:emits a {Sent} event.\\n     *\\n     * @custom:requirements \\n     * - `sender` cannot be the zero address.\\n     * - `sender` must have at least `amount` tokens.\\n     * - the caller must be an operator for `sender`.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function operatorSend(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external override(IERC777);\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\\n     * The caller must be an operator of `account`.\\n     *\\n     * If a send hook is registered for `account`, the corresponding function\\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\\n     *\\n     * @custom:emits a {Burned} event.\\n     *\\n     * @custom:requirements \\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     * - the caller must be an operator for `account`.\\n     */\\n    function operatorBurn(\\n        address account,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external override(IERC777);\\n\\n    /**************************************************************************\\n     * SuperToken custom token functions\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Mint new tokens for the account\\n     *\\n     * @custom:modifiers \\n     *  - onlySelf\\n     */\\n    function selfMint(\\n        address account,\\n        uint256 amount,\\n        bytes memory userData\\n    ) external;\\n\\n   /**\\n    * @dev Burn existing tokens for the account\\n    *\\n    * @custom:modifiers \\n    *  - onlySelf\\n    */\\n   function selfBurn(\\n       address account,\\n       uint256 amount,\\n       bytes memory userData\\n   ) external;\\n\\n   /**\\n    * @dev Transfer `amount` tokens from the `sender` to `recipient`.\\n    * If `spender` isn't the same as `sender`, checks if `spender` has allowance to\\n    * spend tokens of `sender`.\\n    *\\n    * @custom:modifiers \\n    *  - onlySelf\\n    */\\n   function selfTransferFrom(\\n        address sender,\\n        address spender,\\n        address recipient,\\n        uint256 amount\\n   ) external;\\n\\n   /**\\n    * @dev Give `spender`, `amount` allowance to spend the tokens of\\n    * `account`.\\n    *\\n    * @custom:modifiers \\n    *  - onlySelf\\n    */\\n   function selfApproveFor(\\n        address account,\\n        address spender,\\n        uint256 amount\\n   ) external;\\n\\n    /**************************************************************************\\n     * SuperToken extra functions\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Transfer all available balance from `msg.sender` to `recipient`\\n     */\\n    function transferAll(address recipient) external;\\n\\n    /**************************************************************************\\n     * ERC20 wrapping\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Return the underlying token contract\\n     * @return tokenAddr Underlying token address\\n     */\\n    function getUnderlyingToken() external view returns(address tokenAddr);\\n\\n    /**\\n     * @dev Upgrade ERC20 to SuperToken.\\n     * @param amount Number of tokens to be upgraded (in 18 decimals)\\n     *\\n     * @custom:note It will use `transferFrom` to get tokens. Before calling this\\n     * function you should `approve` this contract\\n     */\\n    function upgrade(uint256 amount) external;\\n\\n    /**\\n     * @dev Upgrade ERC20 to SuperToken and transfer immediately\\n     * @param to The account to received upgraded tokens\\n     * @param amount Number of tokens to be upgraded (in 18 decimals)\\n     * @param data User data for the TokensRecipient callback\\n     *\\n     * @custom:note It will use `transferFrom` to get tokens. Before calling this\\n     * function you should `approve` this contract\\n     */\\n    function upgradeTo(address to, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev Token upgrade event\\n     * @param account Account where tokens are upgraded to\\n     * @param amount Amount of tokens upgraded (in 18 decimals)\\n     */\\n    event TokenUpgraded(\\n        address indexed account,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Downgrade SuperToken to ERC20.\\n     * @dev It will call transfer to send tokens\\n     * @param amount Number of tokens to be downgraded\\n     */\\n    function downgrade(uint256 amount) external;\\n\\n    /**\\n     * @dev Token downgrade event\\n     * @param account Account whose tokens are upgraded\\n     * @param amount Amount of tokens downgraded\\n     */\\n    event TokenDowngraded(\\n        address indexed account,\\n        uint256 amount\\n    );\\n\\n    /**************************************************************************\\n    * Batch Operations\\n    *************************************************************************/\\n\\n    /**\\n    * @dev Perform ERC20 approve by host contract.\\n    * @param account The account owner to be approved.\\n    * @param spender The spender of account owner's funds.\\n    * @param amount Number of tokens to be approved.\\n    *\\n    * @custom:modifiers \\n    *  - onlyHost\\n    */\\n    function operationApprove(\\n        address account,\\n        address spender,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n    * @dev Perform ERC20 transfer from by host contract.\\n    * @param account The account to spend sender's funds.\\n    * @param spender  The account where the funds is sent from.\\n    * @param recipient The recipient of thefunds.\\n    * @param amount Number of tokens to be transferred.\\n    *\\n    * @custom:modifiers \\n    *  - onlyHost\\n    */\\n    function operationTransferFrom(\\n        address account,\\n        address spender,\\n        address recipient,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n    * @dev Upgrade ERC20 to SuperToken by host contract.\\n    * @param account The account to be changed.\\n    * @param amount Number of tokens to be upgraded (in 18 decimals)\\n    *\\n    * @custom:modifiers \\n    *  - onlyHost\\n    */\\n    function operationUpgrade(address account, uint256 amount) external;\\n\\n    /**\\n    * @dev Downgrade ERC20 to SuperToken by host contract.\\n    * @param account The account to be changed.\\n    * @param amount Number of tokens to be downgraded (in 18 decimals)\\n    *\\n    * @custom:modifiers \\n    *  - onlyHost\\n    */\\n    function operationDowngrade(address account, uint256 amount) external;\\n\\n\\n    /**************************************************************************\\n    * Function modifiers for access control and parameter validations\\n    *\\n    * While they cannot be explicitly stated in function definitions, they are\\n    * listed in function definition comments instead for clarity.\\n    *\\n    * NOTE: solidity-coverage not supporting it\\n    *************************************************************************/\\n\\n    /// @dev The msg.sender must be the contract itself\\n    //modifier onlySelf() virtual\\n\\n}\\n\",\"keccak256\":\"0xcff22ed43df0f34a645e6cbe0d7c5fd08f204d769e9095bc59d7c2fe6d11b7d6\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperTokenFactory.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\n\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\n\\nimport {\\n    IERC20,\\n    ERC20WithTokenInfo\\n} from \\\"../tokens/ERC20WithTokenInfo.sol\\\";\\n\\n/**\\n * @title Super token factory interface\\n * @author Superfluid\\n */\\ninterface ISuperTokenFactory {\\n\\n    /**\\n     * @dev Get superfluid host contract address\\n     */\\n    function getHost() external view returns(address host);\\n\\n    /// @dev Initialize the contract\\n    function initialize() external;\\n\\n    /**\\n     * @dev Get the current super token logic used by the factory\\n     */\\n    function getSuperTokenLogic() external view returns (ISuperToken superToken);\\n\\n    /**\\n     * @dev Upgradability modes\\n     */\\n    enum Upgradability {\\n        /// Non upgradable super token, `host.updateSuperTokenLogic` will revert\\n        NON_UPGRADABLE,\\n        /// Upgradable through `host.updateSuperTokenLogic` operation\\n        SEMI_UPGRADABLE,\\n        /// Always using the latest super token logic\\n        FULL_UPGRADABE\\n    }\\n\\n    /**\\n     * @dev Create new super token wrapper for the underlying ERC20 token\\n     * @param underlyingToken Underlying ERC20 token\\n     * @param underlyingDecimals Underlying token decimals\\n     * @param upgradability Upgradability mode\\n     * @param name Super token name\\n     * @param symbol Super token symbol\\n     */\\n    function createERC20Wrapper(\\n        IERC20 underlyingToken,\\n        uint8 underlyingDecimals,\\n        Upgradability upgradability,\\n        string calldata name,\\n        string calldata symbol\\n    )\\n        external\\n        returns (ISuperToken superToken);\\n\\n    /**\\n     * @dev Create new super token wrapper for the underlying ERC20 token with extra token info\\n     * @param underlyingToken Underlying ERC20 token\\n     * @param upgradability Upgradability mode\\n     * @param name Super token name\\n     * @param symbol Super token symbol\\n     *\\n     * NOTE:\\n     * - It assumes token provide the .decimals() function\\n     */\\n    function createERC20Wrapper(\\n        ERC20WithTokenInfo underlyingToken,\\n        Upgradability upgradability,\\n        string calldata name,\\n        string calldata symbol\\n    )\\n        external\\n        returns (ISuperToken superToken);\\n\\n    function initializeCustomSuperToken(\\n        address customSuperTokenProxy\\n    )\\n        external;\\n\\n    /**\\n      * @dev Super token logic created event\\n      * @param tokenLogic Token logic address\\n      */\\n    event SuperTokenLogicCreated(ISuperToken indexed tokenLogic);\\n\\n    /**\\n      * @dev Super token created event\\n      * @param token Newly created super token address\\n      */\\n    event SuperTokenCreated(ISuperToken indexed token);\\n\\n    /**\\n      * @dev Custom super token created event\\n      * @param token Newly created custom super token address\\n      */\\n    event CustomSuperTokenCreated(ISuperToken indexed token);\\n\\n}\\n\",\"keccak256\":\"0x68a466c978557e47bd7385b1d7d78f1c8fb07462a870efc5a791008e33a4f535\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluid.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.2;\\n\\nimport { ISuperfluidGovernance } from \\\"./ISuperfluidGovernance.sol\\\";\\nimport { ISuperfluidToken } from \\\"./ISuperfluidToken.sol\\\";\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\nimport { ISuperTokenFactory } from \\\"./ISuperTokenFactory.sol\\\";\\nimport { ISuperAgreement } from \\\"./ISuperAgreement.sol\\\";\\nimport { ISuperApp } from \\\"./ISuperApp.sol\\\";\\nimport {\\n    BatchOperation,\\n    ContextDefinitions,\\n    FlowOperatorDefinitions,\\n    SuperAppDefinitions,\\n    SuperfluidGovernanceConfigs\\n} from \\\"./Definitions.sol\\\";\\nimport { TokenInfo } from \\\"../tokens/TokenInfo.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { IERC777 } from \\\"@openzeppelin/contracts/token/ERC777/IERC777.sol\\\";\\n\\n/**\\n * @title Host interface\\n * @author Superfluid\\n * @notice This is the central contract of the system where super agreement, super app\\n * and super token features are connected.\\n *\\n * The Superfluid host contract is also the entry point for the protocol users,\\n * where batch call and meta transaction are provided for UX improvements.\\n *\\n */\\ninterface ISuperfluid {\\n\\n    /**************************************************************************\\n     * Time\\n     *\\n     * > The Oracle: You have the sight now, Neo. You are looking at the world without time.\\n     * > Neo: Then why can't I see what happens to her?\\n     * > The Oracle: We can never see past the choices we don't understand.\\n     * >       - The Oracle and Neo conversing about the future of Trinity and the effects of Neo's choices\\n     *************************************************************************/\\n\\n    function getNow() external view returns (uint256);\\n\\n    /**************************************************************************\\n     * Governance\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Get the current governance address of the Superfluid host\\n     */\\n    function getGovernance() external view returns(ISuperfluidGovernance governance);\\n\\n    /**\\n     * @dev Replace the current governance with a new one\\n     */\\n    function replaceGovernance(ISuperfluidGovernance newGov) external;\\n    /**\\n     * @dev Governance replaced event\\n     * @param oldGov Address of the old governance contract\\n     * @param newGov Address of the new governance contract\\n     */\\n    event GovernanceReplaced(ISuperfluidGovernance oldGov, ISuperfluidGovernance newGov);\\n\\n    /**************************************************************************\\n     * Agreement Whitelisting\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Register a new agreement class to the system\\n     * @param agreementClassLogic Initial agreement class code\\n     *\\n     * @custom:modifiers \\n     * - onlyGovernance\\n     */\\n    function registerAgreementClass(ISuperAgreement agreementClassLogic) external;\\n    /**\\n     * @notice Agreement class registered event\\n     * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n     * @param agreementType The agreement type registered\\n     * @param code Address of the new agreement\\n     */\\n    event AgreementClassRegistered(bytes32 agreementType, address code);\\n\\n    /**\\n    * @dev Update code of an agreement class\\n    * @param agreementClassLogic New code for the agreement class\\n    *\\n    * @custom:modifiers \\n    *  - onlyGovernance\\n    */\\n    function updateAgreementClass(ISuperAgreement agreementClassLogic) external;\\n    /**\\n     * @notice Agreement class updated event\\n     * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n     * @param agreementType The agreement type updated\\n     * @param code Address of the new agreement\\n     */\\n    event AgreementClassUpdated(bytes32 agreementType, address code);\\n\\n    /**\\n    * @notice Check if the agreement type is whitelisted\\n    * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n    */\\n    function isAgreementTypeListed(bytes32 agreementType) external view returns(bool yes);\\n\\n    /**\\n    * @dev Check if the agreement class is whitelisted\\n    */\\n    function isAgreementClassListed(ISuperAgreement agreementClass) external view returns(bool yes);\\n\\n    /**\\n    * @notice Get agreement class\\n    * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n    */\\n    function getAgreementClass(bytes32 agreementType) external view returns(ISuperAgreement agreementClass);\\n\\n    /**\\n    * @dev Map list of the agreement classes using a bitmap\\n    * @param bitmap Agreement class bitmap\\n    */\\n    function mapAgreementClasses(uint256 bitmap)\\n        external view\\n        returns (ISuperAgreement[] memory agreementClasses);\\n\\n    /**\\n    * @notice Create a new bitmask by adding a agreement class to it\\n    * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n    * @param bitmap Agreement class bitmap\\n    */\\n    function addToAgreementClassesBitmap(uint256 bitmap, bytes32 agreementType)\\n        external view\\n        returns (uint256 newBitmap);\\n\\n    /**\\n    * @notice Create a new bitmask by removing a agreement class from it\\n    * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n    * @param bitmap Agreement class bitmap\\n    */\\n    function removeFromAgreementClassesBitmap(uint256 bitmap, bytes32 agreementType)\\n        external view\\n        returns (uint256 newBitmap);\\n\\n    /**************************************************************************\\n    * Super Token Factory\\n    **************************************************************************/\\n\\n    /**\\n     * @dev Get the super token factory\\n     * @return factory The factory\\n     */\\n    function getSuperTokenFactory() external view returns (ISuperTokenFactory factory);\\n\\n    /**\\n     * @dev Get the super token factory logic (applicable to upgradable deployment)\\n     * @return logic The factory logic\\n     */\\n    function getSuperTokenFactoryLogic() external view returns (address logic);\\n\\n    /**\\n     * @dev Update super token factory\\n     * @param newFactory New factory logic\\n     */\\n    function updateSuperTokenFactory(ISuperTokenFactory newFactory) external;\\n    /**\\n     * @dev SuperToken factory updated event\\n     * @param newFactory Address of the new factory\\n     */\\n    event SuperTokenFactoryUpdated(ISuperTokenFactory newFactory);\\n\\n    /**\\n     * @notice Update the super token logic to the latest\\n     * @dev Refer to ISuperTokenFactory.Upgradability for expected behaviours\\n     */\\n    function updateSuperTokenLogic(ISuperToken token) external;\\n    /**\\n     * @dev SuperToken logic updated event\\n     * @param code Address of the new SuperToken logic\\n     */\\n    event SuperTokenLogicUpdated(ISuperToken indexed token, address code);\\n\\n    /**************************************************************************\\n     * App Registry\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Message sender (must be a contract) declares itself as a super app.\\n     * @custom:deprecated you should use `registerAppWithKey` or `registerAppByFactory` instead,\\n     * because app registration is currently governance permissioned on mainnets.\\n     * @param configWord The super app manifest configuration, flags are defined in\\n     * `SuperAppDefinitions`\\n     */\\n    function registerApp(uint256 configWord) external;\\n    /**\\n     * @dev App registered event\\n     * @param app Address of jailed app\\n     */\\n    event AppRegistered(ISuperApp indexed app);\\n\\n    /**\\n     * @dev Message sender declares itself as a super app.\\n     * @param configWord The super app manifest configuration, flags are defined in `SuperAppDefinitions`\\n     * @param registrationKey The registration key issued by the governance, needed to register on a mainnet.\\n     * @notice See https://github.com/superfluid-finance/protocol-monorepo/wiki/Super-App-White-listing-Guide\\n     * On testnets or in dev environment, a placeholder (e.g. empty string) can be used.\\n     * While the message sender must be the super app itself, the transaction sender (tx.origin)\\n     * must be the deployer account the registration key was issued for.\\n     */\\n    function registerAppWithKey(uint256 configWord, string calldata registrationKey) external;\\n\\n    /**\\n     * @dev Message sender (must be a contract) declares app as a super app\\n     * @param configWord The super app manifest configuration, flags are defined in `SuperAppDefinitions`\\n     * @notice On mainnet deployments, only factory contracts pre-authorized by governance can use this.\\n     * See https://github.com/superfluid-finance/protocol-monorepo/wiki/Super-App-White-listing-Guide\\n     */\\n    function registerAppByFactory(ISuperApp app, uint256 configWord) external;\\n\\n    /**\\n     * @dev Query if the app is registered\\n     * @param app Super app address\\n     */\\n    function isApp(ISuperApp app) external view returns(bool);\\n\\n    /**\\n     * @dev Query app level\\n     * @param app Super app address\\n     */\\n    function getAppLevel(ISuperApp app) external view returns(uint8 appLevel);\\n\\n    /**\\n     * @dev Get the manifest of the super app\\n     * @param app Super app address\\n     */\\n    function getAppManifest(\\n        ISuperApp app\\n    )\\n        external view\\n        returns (\\n            bool isSuperApp,\\n            bool isJailed,\\n            uint256 noopMask\\n        );\\n\\n    /**\\n     * @dev Query if the app has been jailed\\n     * @param app Super app address\\n     */\\n    function isAppJailed(ISuperApp app) external view returns (bool isJail);\\n\\n    /**\\n     * @dev Whitelist the target app for app composition for the source app (msg.sender)\\n     * @param targetApp The target super app address\\n     */\\n    function allowCompositeApp(ISuperApp targetApp) external;\\n\\n    /**\\n     * @dev Query if source app is allowed to call the target app as downstream app\\n     * @param app Super app address\\n     * @param targetApp The target super app address\\n     */\\n    function isCompositeAppAllowed(\\n        ISuperApp app,\\n        ISuperApp targetApp\\n    )\\n        external view\\n        returns (bool isAppAllowed);\\n\\n    /**************************************************************************\\n     * Agreement Framework\\n     *\\n     * Agreements use these function to trigger super app callbacks, updates\\n     * app allowance and charge gas fees.\\n     *\\n     * These functions can only be called by registered agreements.\\n     *************************************************************************/\\n\\n    /**\\n     * @dev (For agreements) StaticCall the app before callback\\n     * @param  app               The super app.\\n     * @param  callData          The call data sending to the super app.\\n     * @param  isTermination     Is it a termination callback?\\n     * @param  ctx               Current ctx, it will be validated.\\n     * @return cbdata            Data returned from the callback.\\n     */\\n    function callAppBeforeCallback(\\n        ISuperApp app,\\n        bytes calldata callData,\\n        bool isTermination,\\n        bytes calldata ctx\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns(bytes memory cbdata);\\n\\n    /**\\n     * @dev (For agreements) Call the app after callback\\n     * @param  app               The super app.\\n     * @param  callData          The call data sending to the super app.\\n     * @param  isTermination     Is it a termination callback?\\n     * @param  ctx               Current ctx, it will be validated.\\n     * @return newCtx            The current context of the transaction.\\n     */\\n    function callAppAfterCallback(\\n        ISuperApp app,\\n        bytes calldata callData,\\n        bool isTermination,\\n        bytes calldata ctx\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @dev (For agreements) Create a new callback stack\\n     * @param  ctx                     The current ctx, it will be validated.\\n     * @param  app                     The super app.\\n     * @param  appAllowanceGranted     App allowance granted so far.\\n     * @param  appAllowanceUsed        App allowance used so far.\\n     * @return newCtx                  The current context of the transaction.\\n     */\\n    function appCallbackPush(\\n        bytes calldata ctx,\\n        ISuperApp app,\\n        uint256 appAllowanceGranted,\\n        int256 appAllowanceUsed,\\n        ISuperfluidToken appAllowanceToken\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev (For agreements) Pop from the current app callback stack\\n     * @param  ctx                     The ctx that was pushed before the callback stack.\\n     * @param  appAllowanceUsedDelta   App allowance used by the app.\\n     * @return newCtx                  The current context of the transaction.\\n     *\\n     * @custom:security \\n     * - Here we cannot do assertValidCtx(ctx), since we do not really save the stack in memory.\\n     * - Hence there is still implicit trust that the agreement handles the callback push/pop pair correctly.\\n     */\\n    function appCallbackPop(\\n        bytes calldata ctx,\\n        int256 appAllowanceUsedDelta\\n    )\\n        external\\n        // onlyAgreement\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev (For agreements) Use app allowance.\\n     * @param  ctx                      The current ctx, it will be validated.\\n     * @param  appAllowanceWantedMore   See app allowance for more details.\\n     * @param  appAllowanceUsedDelta    See app allowance for more details.\\n     * @return newCtx                   The current context of the transaction.\\n     */\\n    function ctxUseAllowance(\\n        bytes calldata ctx,\\n        uint256 appAllowanceWantedMore,\\n        int256 appAllowanceUsedDelta\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev (For agreements) Jail the app.\\n     * @param  app                     The super app.\\n     * @param  reason                  Jail reason code.\\n     * @return newCtx                  The current context of the transaction.\\n     */\\n    function jailApp(\\n        bytes calldata ctx,\\n        ISuperApp app,\\n        uint256 reason\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev Jail event for the app\\n     * @param app Address of jailed app\\n     * @param reason Reason the app is jailed (see Definitions.sol for the full list)\\n     */\\n    event Jail(ISuperApp indexed app, uint256 reason);\\n\\n    /**************************************************************************\\n     * Contextless Call Proxies\\n     *\\n     * NOTE: For EOAs or non-app contracts, they are the entry points for interacting\\n     * with agreements or apps.\\n     *\\n     * NOTE: The contextual call data should be generated using\\n     * abi.encodeWithSelector. The context parameter should be set to \\\"0x\\\",\\n     * an empty bytes array as a placeholder to be replaced by the host\\n     * contract.\\n     *************************************************************************/\\n\\n     /**\\n      * @dev Call agreement function\\n      * @param agreementClass The agreement address you are calling\\n      * @param callData The contextual call data with placeholder ctx\\n      * @param userData Extra user data being sent to the super app callbacks\\n      */\\n     function callAgreement(\\n         ISuperAgreement agreementClass,\\n         bytes calldata callData,\\n         bytes calldata userData\\n     )\\n        external\\n        //cleanCtx\\n        //isAgreement(agreementClass)\\n        returns(bytes memory returnedData);\\n\\n    /**\\n     * @notice Call app action\\n     * @dev Main use case is calling app action in a batch call via the host\\n     * @param callData The contextual call data\\n     *\\n     * @custom:note See \\\"Contextless Call Proxies\\\" above for more about contextual call data.\\n     */\\n    function callAppAction(\\n        ISuperApp app,\\n        bytes calldata callData\\n    )\\n        external\\n        //cleanCtx\\n        //isAppActive(app)\\n        //isValidAppAction(callData)\\n        returns(bytes memory returnedData);\\n\\n    /**************************************************************************\\n     * Contextual Call Proxies and Context Utilities\\n     *\\n     * For apps, they must use context they receive to interact with\\n     * agreements or apps.\\n     *\\n     * The context changes must be saved and returned by the apps in their\\n     * callbacks always, any modification to the context will be detected and\\n     * the violating app will be jailed.\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Context Struct\\n     *\\n     * @custom:note on backward compatibility:\\n     * - Non-dynamic fields are padded to 32bytes and packed\\n     * - Dynamic fields are referenced through a 32bytes offset to their \\\"parents\\\" field (or root)\\n     * - The order of the fields hence should not be rearranged in order to be backward compatible:\\n     *    - non-dynamic fields will be parsed at the same memory location,\\n     *    - and dynamic fields will simply have a greater offset than it was.\\n     */\\n    struct Context {\\n        //\\n        // Call context\\n        //\\n        // callback level\\n        uint8 appLevel;\\n        // type of call\\n        uint8 callType;\\n        // the system timestamp\\n        uint256 timestamp;\\n        // The intended message sender for the call\\n        address msgSender;\\n\\n        //\\n        // Callback context\\n        //\\n        // For callbacks it is used to know which agreement function selector is called\\n        bytes4 agreementSelector;\\n        // User provided data for app callbacks\\n        bytes userData;\\n\\n        //\\n        // App context\\n        //\\n        // app allowance granted\\n        uint256 appAllowanceGranted;\\n        // app allowance wanted by the app callback\\n        uint256 appAllowanceWanted;\\n        // app allowance used, allowing negative values over a callback session\\n        int256 appAllowanceUsed;\\n        // app address\\n        address appAddress;\\n        // app allowance in super token\\n        ISuperfluidToken appAllowanceToken;\\n    }\\n\\n    function callAgreementWithContext(\\n        ISuperAgreement agreementClass,\\n        bytes calldata callData,\\n        bytes calldata userData,\\n        bytes calldata ctx\\n    )\\n        external\\n        // requireValidCtx(ctx)\\n        // onlyAgreement(agreementClass)\\n        returns (bytes memory newCtx, bytes memory returnedData);\\n\\n    function callAppActionWithContext(\\n        ISuperApp app,\\n        bytes calldata callData,\\n        bytes calldata ctx\\n    )\\n        external\\n        // requireValidCtx(ctx)\\n        // isAppActive(app)\\n        returns (bytes memory newCtx);\\n\\n    function decodeCtx(bytes calldata ctx)\\n        external pure\\n        returns (Context memory context);\\n\\n    function isCtxValid(bytes calldata ctx) external view returns (bool);\\n\\n    /**************************************************************************\\n    * Batch call\\n    **************************************************************************/\\n    /**\\n     * @dev Batch operation data\\n     */\\n    struct Operation {\\n        // Operation type. Defined in BatchOperation (Definitions.sol)\\n        uint32 operationType;\\n        // Operation target\\n        address target;\\n        // Data specific to the operation\\n        bytes data;\\n    }\\n\\n    /**\\n     * @dev Batch call function\\n     * @param operations Array of batch operations\\n     */\\n    function batchCall(Operation[] memory operations) external;\\n\\n    /**\\n     * @dev Batch call function for trusted forwarders (EIP-2771)\\n     * @param operations Array of batch operations\\n     */\\n    function forwardBatchCall(Operation[] memory operations) external;\\n\\n    /**************************************************************************\\n     * Function modifiers for access control and parameter validations\\n     *\\n     * While they cannot be explicitly stated in function definitions, they are\\n     * listed in function definition comments instead for clarity.\\n     *\\n     * TODO: turning these off because solidity-coverage doesn't like it\\n     *************************************************************************/\\n\\n     /* /// @dev The current superfluid context is clean.\\n     modifier cleanCtx() virtual;\\n\\n     /// @dev Require the ctx being valid.\\n     modifier requireValidCtx(bytes memory ctx) virtual;\\n\\n     /// @dev Assert the ctx being valid.\\n     modifier assertValidCtx(bytes memory ctx) virtual;\\n\\n     /// @dev The agreement is a listed agreement.\\n     modifier isAgreement(ISuperAgreement agreementClass) virtual;\\n\\n     // onlyGovernance\\n\\n     /// @dev The msg.sender must be a listed agreement.\\n     modifier onlyAgreement() virtual;\\n\\n     /// @dev The app is registered and not jailed.\\n     modifier isAppActive(ISuperApp app) virtual; */\\n}\\n\",\"keccak256\":\"0xf16efd1ba72322e77e0d936b723c0e71eb14c23e11cf69efae8c7caa407012cf\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluidGovernance.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\n\\nimport { ISuperAgreement } from \\\"./ISuperAgreement.sol\\\";\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\nimport { ISuperfluidToken  } from \\\"./ISuperfluidToken.sol\\\";\\nimport { ISuperfluid } from \\\"./ISuperfluid.sol\\\";\\n\\n\\n/**\\n * @title Superfluid governance interface\\n * @author Superfluid\\n */\\ninterface ISuperfluidGovernance {\\n\\n    /**\\n     * @dev Replace the current governance with a new governance\\n     */\\n    function replaceGovernance(\\n        ISuperfluid host,\\n        address newGov) external;\\n\\n    /**\\n     * @dev Register a new agreement class\\n     */\\n    function registerAgreementClass(\\n        ISuperfluid host,\\n        address agreementClass) external;\\n\\n    /**\\n     * @dev Update logics of the contracts\\n     *\\n     * @custom:note \\n     * - Because they might have inter-dependencies, it is good to have one single function to update them all\\n     */\\n    function updateContracts(\\n        ISuperfluid host,\\n        address hostNewLogic,\\n        address[] calldata agreementClassNewLogics,\\n        address superTokenFactoryNewLogic\\n    ) external;\\n\\n    /**\\n     * @dev Update supertoken logic contract to the latest that is managed by the super token factory\\n     */\\n    function batchUpdateSuperTokenLogic(\\n        ISuperfluid host,\\n        ISuperToken[] calldata tokens) external;\\n    \\n    /**\\n     * @dev Set configuration as address value\\n     */\\n    function setConfig(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key,\\n        address value\\n    ) external;\\n    \\n    /**\\n     * @dev Set configuration as uint256 value\\n     */\\n    function setConfig(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key,\\n        uint256 value\\n    ) external;\\n\\n    /**\\n     * @dev Clear configuration\\n     */\\n    function clearConfig(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key\\n    ) external;\\n\\n    /**\\n     * @dev Get configuration as address value\\n     */\\n    function getConfigAsAddress(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key) external view returns (address value);\\n\\n    /**\\n     * @dev Get configuration as uint256 value\\n     */\\n    function getConfigAsUint256(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key) external view returns (uint256 value);\\n\\n}\\n\",\"keccak256\":\"0xea33d20751ffea4f4446bc04f6c10194fb4da0803a988586d41d49cf4859731c\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluidToken.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\n\\nimport { ISuperAgreement } from \\\"./ISuperAgreement.sol\\\";\\n\\n\\n/**\\n * @title Superfluid token interface\\n * @author Superfluid\\n */\\ninterface ISuperfluidToken {\\n\\n    /**************************************************************************\\n     * Basic information\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Get superfluid host contract address\\n     */\\n    function getHost() external view returns(address host);\\n\\n    /**\\n     * @dev Encoded liquidation type data mainly used for handling stack to deep errors\\n     *\\n     * @custom:note \\n     * - version: 1\\n     * - liquidationType key:\\n     *    - 0 = reward account receives reward (PIC period)\\n     *    - 1 = liquidator account receives reward (Pleb period)\\n     *    - 2 = liquidator account receives reward (Pirate period/bailout)\\n     */\\n    struct LiquidationTypeData {\\n        uint256 version;\\n        uint8 liquidationType;\\n    }\\n\\n    /**************************************************************************\\n     * Real-time balance functions\\n     *************************************************************************/\\n\\n    /**\\n    * @dev Calculate the real balance of a user, taking in consideration all agreements of the account\\n    * @param account for the query\\n    * @param timestamp Time of balance\\n    * @return availableBalance Real-time balance\\n    * @return deposit Account deposit\\n    * @return owedDeposit Account owed Deposit\\n    */\\n    function realtimeBalanceOf(\\n       address account,\\n       uint256 timestamp\\n    )\\n        external view\\n        returns (\\n            int256 availableBalance,\\n            uint256 deposit,\\n            uint256 owedDeposit);\\n\\n    /**\\n     * @notice Calculate the realtime balance given the current host.getNow() value\\n     * @dev realtimeBalanceOf with timestamp equals to block timestamp\\n     * @param account for the query\\n     * @return availableBalance Real-time balance\\n     * @return deposit Account deposit\\n     * @return owedDeposit Account owed Deposit\\n     */\\n    function realtimeBalanceOfNow(\\n       address account\\n    )\\n        external view\\n        returns (\\n            int256 availableBalance,\\n            uint256 deposit,\\n            uint256 owedDeposit,\\n            uint256 timestamp);\\n\\n    /**\\n    * @notice Check if account is critical\\n    * @dev A critical account is when availableBalance < 0\\n    * @param account The account to check\\n    * @param timestamp The time we'd like to check if the account is critical (should use future)\\n    * @return isCritical Whether the account is critical\\n    */\\n    function isAccountCritical(\\n        address account,\\n        uint256 timestamp\\n    )\\n        external view\\n        returns(bool isCritical);\\n\\n    /**\\n    * @notice Check if account is critical now (current host.getNow())\\n    * @dev A critical account is when availableBalance < 0\\n    * @param account The account to check\\n    * @return isCritical Whether the account is critical\\n    */\\n    function isAccountCriticalNow(\\n        address account\\n    )\\n        external view\\n        returns(bool isCritical);\\n\\n    /**\\n     * @notice Check if account is solvent\\n     * @dev An account is insolvent when the sum of deposits for a token can't cover the negative availableBalance\\n     * @param account The account to check\\n     * @param timestamp The time we'd like to check if the account is solvent (should use future)\\n     * @return isSolvent True if the account is solvent, false otherwise\\n     */\\n    function isAccountSolvent(\\n        address account,\\n        uint256 timestamp\\n    )\\n        external view\\n        returns(bool isSolvent);\\n\\n    /**\\n     * @notice Check if account is solvent now\\n     * @dev An account is insolvent when the sum of deposits for a token can't cover the negative availableBalance\\n     * @param account The account to check\\n     * @return isSolvent True if the account is solvent, false otherwise\\n     */\\n    function isAccountSolventNow(\\n        address account\\n    )\\n        external view\\n        returns(bool isSolvent);\\n\\n    /**\\n    * @notice Get a list of agreements that is active for the account\\n    * @dev An active agreement is one that has state for the account\\n    * @param account Account to query\\n    * @return activeAgreements List of accounts that have non-zero states for the account\\n    */\\n    function getAccountActiveAgreements(address account)\\n       external view\\n       returns(ISuperAgreement[] memory activeAgreements);\\n\\n\\n   /**************************************************************************\\n    * Super Agreement hosting functions\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Create a new agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    function createAgreement(\\n        bytes32 id,\\n        bytes32[] calldata data\\n    )\\n        external;\\n    /**\\n     * @dev Agreement created event\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    event AgreementCreated(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        bytes32[] data\\n    );\\n\\n    /**\\n     * @dev Get data of the agreement\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @return data Data of the agreement\\n     */\\n    function getAgreementData(\\n        address agreementClass,\\n        bytes32 id,\\n        uint dataLength\\n    )\\n        external view\\n        returns(bytes32[] memory data);\\n\\n    /**\\n     * @dev Create a new agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    function updateAgreementData(\\n        bytes32 id,\\n        bytes32[] calldata data\\n    )\\n        external;\\n    /**\\n     * @dev Agreement updated event\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    event AgreementUpdated(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        bytes32[] data\\n    );\\n\\n    /**\\n     * @dev Close the agreement\\n     * @param id Agreement ID\\n     */\\n    function terminateAgreement(\\n        bytes32 id,\\n        uint dataLength\\n    )\\n        external;\\n    /**\\n     * @dev Agreement terminated event\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     */\\n    event AgreementTerminated(\\n        address indexed agreementClass,\\n        bytes32 id\\n    );\\n\\n    /**\\n     * @dev Update agreement state slot\\n     * @param account Account to be updated\\n     *\\n     * @custom:note \\n     * - To clear the storage out, provide zero-ed array of intended length\\n     */\\n    function updateAgreementStateSlot(\\n        address account,\\n        uint256 slotId,\\n        bytes32[] calldata slotData\\n    )\\n        external;\\n    /**\\n     * @dev Agreement account state updated event\\n     * @param agreementClass Contract address of the agreement\\n     * @param account Account updated\\n     * @param slotId slot id of the agreement state\\n     */\\n    event AgreementStateUpdated(\\n        address indexed agreementClass,\\n        address indexed account,\\n        uint256 slotId\\n    );\\n\\n    /**\\n     * @dev Get data of the slot of the state of an agreement\\n     * @param agreementClass Contract address of the agreement\\n     * @param account Account to query\\n     * @param slotId slot id of the state\\n     * @param dataLength length of the state data\\n     */\\n    function getAgreementStateSlot(\\n        address agreementClass,\\n        address account,\\n        uint256 slotId,\\n        uint dataLength\\n    )\\n        external view\\n        returns (bytes32[] memory slotData);\\n\\n    /**\\n     * @notice Settle balance from an account by the agreement\\n     * @dev The agreement needs to make sure that the balance delta is balanced afterwards\\n     * @param account Account to query.\\n     * @param delta Amount of balance delta to be settled\\n     *\\n     * @custom:modifiers \\n     *  - onlyAgreement\\n     */\\n    function settleBalance(\\n        address account,\\n        int256 delta\\n    )\\n        external;\\n\\n    /**\\n     * @dev Make liquidation payouts (v2)\\n     * @param id Agreement ID\\n     * @param liquidationTypeData Data regarding the version of the liquidation schema and the type\\n     * @param liquidatorAccount Address of the executor of the liquidation\\n     * @param useDefaultRewardAccount Whether or not the default reward account receives the rewardAmount\\n     * @param targetAccount Account to be liquidated\\n     * @param rewardAmount The amount the rewarded account will receive\\n     * @param targetAccountBalanceDelta The delta amount the target account balance should change by\\n     *\\n     * @custom:note \\n     * - If a bailout is required (bailoutAmount > 0)\\n     *   - the actual reward (single deposit) goes to the executor,\\n     *   - while the reward account becomes the bailout account\\n     *   - total bailout include: bailout amount + reward amount\\n     *   - the targetAccount will be bailed out\\n     * - If a bailout is not required\\n     *   - the targetAccount will pay the rewardAmount\\n     *   - the liquidator (reward account in PIC period) will receive the rewardAmount\\n     *\\n     * @custom:modifiers \\n     *  - onlyAgreement\\n     */\\n    function makeLiquidationPayoutsV2\\n    (\\n        bytes32 id,\\n        bytes memory liquidationTypeData,\\n        address liquidatorAccount,\\n        bool useDefaultRewardAccount,\\n        address targetAccount,\\n        uint256 rewardAmount,\\n        int256 targetAccountBalanceDelta\\n    ) external;\\n    /**\\n     * @dev Agreement liquidation event v2 (including agent account)\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param liquidatorAccount Address of the executor of the liquidation\\n     * @param targetAccount Account of the stream sender\\n     * @param rewardAmountReceiver Account that collects the reward or bails out insolvent accounts\\n     * @param rewardAmount The amount the reward recipient account balance should change by\\n     * @param targetAccountBalanceDelta The amount the sender account balance should change by\\n     * @param liquidationTypeData The encoded liquidation type data including the version (how to decode)\\n     *\\n     * @custom:note \\n     * Reward account rule:\\n     * - if the agreement is liquidated during the PIC period\\n     *   - the rewardAmountReceiver will get the rewardAmount (remaining deposit), regardless of the liquidatorAccount\\n     *   - the targetAccount will pay for the rewardAmount\\n     * - if the agreement is liquidated after the PIC period AND the targetAccount is solvent\\n     *   - the rewardAmountReceiver will get the rewardAmount (remaining deposit)\\n     *   - the targetAccount will pay for the rewardAmount\\n     * - if the targetAccount is insolvent\\n     *   - the liquidatorAccount will get the rewardAmount (single deposit)\\n     *   - the default reward account (governance) will pay for both the rewardAmount and bailoutAmount\\n     *   - the targetAccount will receive the bailoutAmount\\n     */\\n    event AgreementLiquidatedV2(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        address indexed liquidatorAccount,\\n        address indexed targetAccount,\\n        address rewardAmountReceiver,\\n        uint256 rewardAmount,\\n        int256 targetAccountBalanceDelta,\\n        bytes liquidationTypeData\\n    );\\n\\n    /**************************************************************************\\n     * Function modifiers for access control and parameter validations\\n     *\\n     * While they cannot be explicitly stated in function definitions, they are\\n     * listed in function definition comments instead for clarity.\\n     *\\n     * NOTE: solidity-coverage not supporting it\\n     *************************************************************************/\\n\\n     /// @dev The msg.sender must be host contract\\n     //modifier onlyHost() virtual;\\n\\n    /// @dev The msg.sender must be a listed agreement.\\n    //modifier onlyAgreement() virtual;\\n\\n    /**************************************************************************\\n     * DEPRECATED\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Agreement liquidation event (DEPRECATED BY AgreementLiquidatedBy)\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param penaltyAccount Account of the agreement to be penalized\\n     * @param rewardAccount Account that collect the reward\\n     * @param rewardAmount Amount of liquidation reward\\n     *\\n     * @custom:deprecated Use AgreementLiquidatedV2 instead\\n     */\\n    event AgreementLiquidated(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        address indexed penaltyAccount,\\n        address indexed rewardAccount,\\n        uint256 rewardAmount\\n    );\\n\\n    /**\\n     * @dev System bailout occurred (DEPRECATED BY AgreementLiquidatedBy)\\n     * @param bailoutAccount Account that bailout the penalty account\\n     * @param bailoutAmount Amount of account bailout\\n     *\\n     * @custom:deprecated Use AgreementLiquidatedV2 instead\\n     */\\n    event Bailout(\\n        address indexed bailoutAccount,\\n        uint256 bailoutAmount\\n    );\\n\\n    /**\\n     * @dev Agreement liquidation event (DEPRECATED BY AgreementLiquidatedV2)\\n     * @param liquidatorAccount Account of the agent that performed the liquidation.\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param penaltyAccount Account of the agreement to be penalized\\n     * @param bondAccount Account that collect the reward or bailout accounts\\n     * @param rewardAmount Amount of liquidation reward\\n     * @param bailoutAmount Amount of liquidation bailouot\\n     *\\n     * @custom:deprecated Use AgreementLiquidatedV2 instead\\n     *\\n     * @custom:note \\n     * Reward account rule:\\n     * - if bailout is equal to 0, then\\n     *   - the bondAccount will get the rewardAmount,\\n     *   - the penaltyAccount will pay for the rewardAmount.\\n     * - if bailout is larger than 0, then\\n     *   - the liquidatorAccount will get the rewardAmouont,\\n     *   - the bondAccount will pay for both the rewardAmount and bailoutAmount,\\n     *   - the penaltyAccount will pay for the rewardAmount while get the bailoutAmount.\\n     */\\n    event AgreementLiquidatedBy(\\n        address liquidatorAccount,\\n        address indexed agreementClass,\\n        bytes32 id,\\n        address indexed penaltyAccount,\\n        address indexed bondAccount,\\n        uint256 rewardAmount,\\n        uint256 bailoutAmount\\n    );\\n}\\n\",\"keccak256\":\"0x3eec5a3bf337cd319c1918fd1b16f350cf5f6850ac71f6859066fbf86e734ff4\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/tokens/ERC20WithTokenInfo.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { TokenInfo } from \\\"./TokenInfo.sol\\\";\\n\\n/**\\n * @title ERC20 token with token info interface\\n * @author Superfluid\\n * @dev Using abstract contract instead of interfaces because old solidity\\n *      does not support interface inheriting other interfaces\\n * solhint-disable-next-line no-empty-blocks\\n *\\n */\\n// solhint-disable-next-line no-empty-blocks\\nabstract contract ERC20WithTokenInfo is IERC20, TokenInfo {}\\n\",\"keccak256\":\"0x66708dae3fcd06e6fc0a46f2959fc2d1e6b9361f28598337339d26af8eb8c0f9\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/tokens/TokenInfo.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\n\\n/**\\n * @title ERC20 token info interface\\n * @author Superfluid\\n * @dev ERC20 standard interface does not specify these functions, but\\n *      often the token implementations have them.\\n */\\ninterface TokenInfo {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x70e573644a0ff271c0ccef526809e9d9ab4950ec58755ca84e833cde3b8f3df0\",\"license\":\"AGPLv3\"},\"contracts/NFTSpread.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.14;\\n\\nimport {ISuperfluid, ISuperToken, SuperAppBase, SuperAppDefinitions} from '@superfluid-finance/ethereum-contracts/contracts/apps/SuperAppBase.sol';\\nimport {IInstantDistributionAgreementV1} from '@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/IInstantDistributionAgreementV1.sol';\\n\\nimport {IDAv1Library} from '@superfluid-finance/ethereum-contracts/contracts/apps/IDAv1Library.sol';\\n\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\\n\\ncontract NFTSpread {\\n    /// @notice Super token to be distributed.\\n    ISuperToken public spreaderToken;\\n\\n    /// @notice IDA Library\\n    using IDAv1Library for IDAv1Library.InitData;\\n    IDAv1Library.InitData public idaV1;\\n\\n    uint32 public constant INDEX_ID = 0;\\n\\n    constructor(ISuperfluid _host, ISuperToken _spreaderToken) {\\n        spreaderToken = _spreaderToken;\\n\\n        // IDA Library Initialize.\\n        idaV1 = IDAv1Library.InitData(\\n            _host,\\n            IInstantDistributionAgreementV1(\\n                address(\\n                    _host.getAgreementClass(\\n                        keccak256(\\n                            'org.superfluid-finance.agreements.InstantDistributionAgreement.v1'\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n\\n        idaV1.createIndex(spreaderToken, INDEX_ID);\\n    }\\n\\n    // todo verify request comes from MyNFT\\n    function gainShare(address subscriber, uint256 units) external {\\n        // Get current units subscriber holds\\n        (, , uint256 currentUnitsHeld, ) = idaV1.getSubscription(\\n            spreaderToken,\\n            address(this),\\n            INDEX_ID,\\n            subscriber\\n        );\\n\\n        // Update to current amount + 1\\n        idaV1.updateSubscriptionUnits(\\n            spreaderToken,\\n            INDEX_ID,\\n            subscriber,\\n            uint128(currentUnitsHeld + units)\\n        );\\n    }\\n\\n    //  todo verify request comes from MyNFT\\n    /// @notice lets an account lose a single distribution unit\\n    /// @param subscriber subscriber address whose units are to be decremented\\n    function loseShare(address subscriber) external {\\n        // Get current units subscriber holds\\n        (, , uint256 currentUnitsHeld, ) = idaV1.getSubscription(\\n            spreaderToken,\\n            address(this),\\n            INDEX_ID,\\n            subscriber\\n        );\\n\\n        // Update to current amount - 1 (reverts if currentUnitsHeld - 1 < 0, so basically if currentUnitsHeld = 0)\\n        idaV1.updateSubscriptionUnits(\\n            spreaderToken,\\n            INDEX_ID,\\n            subscriber,\\n            uint128(currentUnitsHeld - 1)\\n        );\\n    }\\n\\n    /// @notice allows an account to delete its entire subscription this contract\\n    /// @param subscriber subscriber address whose subscription is to be deleted\\n    function deleteShares(address subscriber) external {\\n        idaV1.deleteSubscription(\\n            spreaderToken,\\n            address(this),\\n            INDEX_ID,\\n            subscriber\\n        );\\n    }\\n\\n    /// @notice Takes the entire balance of the designated spreaderToken in the contract and distributes it out to unit holders w/ IDA\\n    function distribute(uint256 amount) public {\\n        spreaderToken.transferFrom(msg.sender, address(this), amount);\\n\\n        (uint256 actualDistributionAmount, ) = idaV1.ida.calculateDistribution(\\n            spreaderToken,\\n            address(this),\\n            INDEX_ID,\\n            amount\\n        );\\n\\n        idaV1.distribute(spreaderToken, INDEX_ID, actualDistributionAmount);\\n    }\\n}\\n\",\"keccak256\":\"0x2d2c8f3ef8a0839f32595997d10c067ada2ee397d6dc9eedea61fbe9db015532\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001157600080fd5b50604051620021133803806200211383398181016040528101906200003791906200052d565b806000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060405180604001604052808373ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1663b6d200de7f8aedc3b5d4bf031e11a7e2940f7251c005698405d58e02e1c247fed3b1b3a6746040518263ffffffff1660e01b8152600401620000f991906200058f565b602060405180830381865afa15801562000117573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200013d9190620005f1565b73ffffffffffffffffffffffffffffffffffffffff16815250600160008201518160000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060208201518160010160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055509050506200022760008054906101000a900473ffffffffffffffffffffffffffffffffffffffff16600060016200022f60201b620004eb179092919060201c565b50506200099a565b62000294838383600067ffffffffffffffff81111562000254576200025362000623565b5b6040519080825280601f01601f191660200182016040528015620002875781602001600182028036833780820191505090505b506200029960201b60201c565b505050565b8360000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166339255d5b8560010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff168660010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d787840a8787600067ffffffffffffffff8111156200035e576200035d62000623565b5b6040519080825280601f01601f191660200182016040528015620003915781602001600182028036833780820191505090505b50604051602401620003a69392919062000782565b604051602081830303815290604052915060e01b6020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050846040518463ffffffff1660e01b81526004016200040993929190620007eb565b6000604051808303816000875af115801562000429573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f8201168201806040525081019062000454919062000949565b5050505050565b6000604051905090565b600080fd5b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006200049c826200046f565b9050919050565b6000620004b0826200048f565b9050919050565b620004c281620004a3565b8114620004ce57600080fd5b50565b600081519050620004e281620004b7565b92915050565b6000620004f5826200048f565b9050919050565b6200050781620004e8565b81146200051357600080fd5b50565b6000815190506200052781620004fc565b92915050565b6000806040838503121562000547576200054662000465565b5b60006200055785828601620004d1565b92505060206200056a8582860162000516565b9150509250929050565b6000819050919050565b620005898162000574565b82525050565b6000602082019050620005a660008301846200057e565b92915050565b6000620005b9826200048f565b9050919050565b620005cb81620005ac565b8114620005d757600080fd5b50565b600081519050620005eb81620005c0565b92915050565b6000602082840312156200060a576200060962000465565b5b60006200061a84828501620005da565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6000819050919050565b60006200067d6200067762000671846200046f565b62000652565b6200046f565b9050919050565b600062000691826200065c565b9050919050565b6000620006a58262000684565b9050919050565b620006b78162000698565b82525050565b600063ffffffff82169050919050565b620006d881620006bd565b82525050565b600081519050919050565b600082825260208201905092915050565b60005b838110156200071a578082015181840152602081019050620006fd565b838111156200072a576000848401525b50505050565b6000601f19601f8301169050919050565b60006200074e82620006de565b6200075a8185620006e9565b93506200076c818560208601620006fa565b620007778162000730565b840191505092915050565b6000606082019050620007996000830186620006ac565b620007a86020830185620006cd565b8181036040830152620007bc818462000741565b9050949350505050565b6000620007d38262000684565b9050919050565b620007e581620007c6565b82525050565b6000606082019050620008026000830186620007da565b818103602083015262000816818562000741565b905081810360408301526200082c818462000741565b9050949350505050565b600080fd5b600080fd5b6200084b8262000730565b810181811067ffffffffffffffff821117156200086d576200086c62000623565b5b80604052505050565b6000620008826200045b565b905062000890828262000840565b919050565b600067ffffffffffffffff821115620008b357620008b262000623565b5b620008be8262000730565b9050602081019050919050565b6000620008e2620008dc8462000895565b62000876565b9050828152602081018484840111156200090157620009006200083b565b5b6200090e848285620006fa565b509392505050565b600082601f8301126200092e576200092d62000836565b5b815162000940848260208601620008cb565b91505092915050565b60006020828403121562000962576200096162000465565b5b600082015167ffffffffffffffff8111156200098357620009826200046a565b5b620009918482850162000916565b91505092915050565b61176980620009aa6000396000f3fe608060405234801561001057600080fd5b506004361061007d5760003560e01c8063844a5f5f1161005b578063844a5f5f146100d95780638c7f0959146100f757806391c05b0b14610115578063d58a8828146101315761007d565b80631cc8ca99146100825780632268cacb146100a15780634f514382146100bd575b600080fd5b61008a61014d565b604051610098929190610eb6565b60405180910390f35b6100bb60048036038101906100b69190610f31565b61019f565b005b6100d760048036038101906100d29190610f94565b6101dd565b005b6100e161027c565b6040516100ee9190610ff5565b60405180910390f35b6100ff6102a0565b60405161010c919061102f565b60405180910390f35b61012f600480360381019061012a919061104a565b6102a5565b005b61014b60048036038101906101469190610f31565b61044c565b005b60018060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16908060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905082565b6101da60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1630600084600161054990949392919063ffffffff16565b50565b600061021a60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff163060008660016105ab90949392919063ffffffff16565b506fffffffffffffffffffffffffffffffff169250505061027760008054906101000a900473ffffffffffffffffffffffffffffffffffffffff16600085858561026491906110a6565b600161066990949392919063ffffffff16565b505050565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600081565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd3330846040518463ffffffff1660e01b81526004016103029392919061111a565b6020604051808303816000875af1158015610321573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103459190611189565b5060006001800160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663899baaec60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff16306000866040518563ffffffff1660e01b81526004016103cc94939291906111b6565b6040805180830381865afa1580156103e8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061040c9190611258565b50905061044860008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1660008360016106cb909392919063ffffffff16565b5050565b600061048960008054906101000a900473ffffffffffffffffffffffffffffffffffffffff163060008560016105ab90949392919063ffffffff16565b506fffffffffffffffffffffffffffffffff16925050506104e760008054906101000a900473ffffffffffffffffffffffffffffffffffffffff166000846001856104d49190611298565b600161066990949392919063ffffffff16565b5050565b610544838383600067ffffffffffffffff81111561050c5761050b6112cc565b5b6040519080825280601f01601f19166020018201604052801561053e5781602001600182028036833780820191505090505b5061072b565b505050565b6105a48585858585600067ffffffffffffffff81111561056c5761056b6112cc565b5b6040519080825280601f01601f19166020018201604052801561059e5781602001600182028036833780820191505090505b506108e2565b5050505050565b6000806000808860010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16635b534051898989896040518563ffffffff1660e01b8152600401610614949392919061131c565b608060405180830381865afa158015610631573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106559190611361565b935093509350935095509550955095915050565b6106c48585858585600067ffffffffffffffff81111561068c5761068b6112cc565b5b6040519080825280601f01601f1916602001820160405280156106be5781602001600182028036833780820191505090505b50610a9f565b5050505050565b61072584848484600067ffffffffffffffff8111156106ed576106ec6112cc565b5b6040519080825280601f01601f19166020018201604052801561071f5781602001600182028036833780820191505090505b50610c5c565b50505050565b8360000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166339255d5b8560010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff168660010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d787840a8787600067ffffffffffffffff8111156107ed576107ec6112cc565b5b6040519080825280601f01601f19166020018201604052801561081f5781602001600182028036833780820191505090505b5060405160240161083293929190611461565b604051602081830303815290604052915060e01b6020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050846040518463ffffffff1660e01b81526004016108939392919061149f565b6000604051808303816000875af11580156108b2573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906108db91906115db565b5050505050565b8560000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166339255d5b8760010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff168860010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16632e5e74c689898989600067ffffffffffffffff8111156109a6576109a56112cc565b5b6040519080825280601f01601f1916602001820160405280156109d85781602001600182028036833780820191505090505b506040516024016109ed959493929190611624565b604051602081830303815290604052915060e01b6020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050846040518463ffffffff1660e01b8152600401610a4e9392919061149f565b6000604051808303816000875af1158015610a6d573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f82011682018060405250810190610a9691906115db565b50505050505050565b8560000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166339255d5b8760010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff168860010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663232d2b5889898989600067ffffffffffffffff811115610b6357610b626112cc565b5b6040519080825280601f01601f191660200182016040528015610b955781602001600182028036833780820191505090505b50604051602401610baa95949392919061168d565b604051602081830303815290604052915060e01b6020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050846040518463ffffffff1660e01b8152600401610c0b9392919061149f565b6000604051808303816000875af1158015610c2a573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f82011682018060405250810190610c5391906115db565b50505050505050565b8460000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166339255d5b8660010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff168760010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663b96731c2888888600067ffffffffffffffff811115610d1f57610d1e6112cc565b5b6040519080825280601f01601f191660200182016040528015610d515781602001600182028036833780820191505090505b50604051602401610d6594939291906116e7565b604051602081830303815290604052915060e01b6020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050846040518463ffffffff1660e01b8152600401610dc69392919061149f565b6000604051808303816000875af1158015610de5573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f82011682018060405250810190610e0e91906115db565b505050505050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b6000610e5b610e56610e5184610e16565b610e36565b610e16565b9050919050565b6000610e6d82610e40565b9050919050565b6000610e7f82610e62565b9050919050565b610e8f81610e74565b82525050565b6000610ea082610e62565b9050919050565b610eb081610e95565b82525050565b6000604082019050610ecb6000830185610e86565b610ed86020830184610ea7565b9392505050565b6000604051905090565b600080fd5b600080fd5b6000610efe82610e16565b9050919050565b610f0e81610ef3565b8114610f1957600080fd5b50565b600081359050610f2b81610f05565b92915050565b600060208284031215610f4757610f46610ee9565b5b6000610f5584828501610f1c565b91505092915050565b6000819050919050565b610f7181610f5e565b8114610f7c57600080fd5b50565b600081359050610f8e81610f68565b92915050565b60008060408385031215610fab57610faa610ee9565b5b6000610fb985828601610f1c565b9250506020610fca85828601610f7f565b9150509250929050565b6000610fdf82610e62565b9050919050565b610fef81610fd4565b82525050565b600060208201905061100a6000830184610fe6565b92915050565b600063ffffffff82169050919050565b61102981611010565b82525050565b60006020820190506110446000830184611020565b92915050565b6000602082840312156110605761105f610ee9565b5b600061106e84828501610f7f565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60006110b182610f5e565b91506110bc83610f5e565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff038211156110f1576110f0611077565b5b828201905092915050565b61110581610ef3565b82525050565b61111481610f5e565b82525050565b600060608201905061112f60008301866110fc565b61113c60208301856110fc565b611149604083018461110b565b949350505050565b60008115159050919050565b61116681611151565b811461117157600080fd5b50565b6000815190506111838161115d565b92915050565b60006020828403121561119f5761119e610ee9565b5b60006111ad84828501611174565b91505092915050565b60006080820190506111cb6000830187610fe6565b6111d860208301866110fc565b6111e56040830185611020565b6111f2606083018461110b565b95945050505050565b60008151905061120a81610f68565b92915050565b60006fffffffffffffffffffffffffffffffff82169050919050565b61123581611210565b811461124057600080fd5b50565b6000815190506112528161122c565b92915050565b6000806040838503121561126f5761126e610ee9565b5b600061127d858286016111fb565b925050602061128e85828601611243565b9150509250929050565b60006112a382610f5e565b91506112ae83610f5e565b9250828210156112c1576112c0611077565b5b828203905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600061130682610e62565b9050919050565b611316816112fb565b82525050565b6000608082019050611331600083018761130d565b61133e60208301866110fc565b61134b6040830185611020565b61135860608301846110fc565b95945050505050565b6000806000806080858703121561137b5761137a610ee9565b5b600061138987828801611174565b945050602061139a87828801611174565b93505060406113ab87828801611243565b92505060606113bc878288016111fb565b91505092959194509250565b600081519050919050565b600082825260208201905092915050565b60005b838110156114025780820151818401526020810190506113e7565b83811115611411576000848401525b50505050565b6000601f19601f8301169050919050565b6000611433826113c8565b61143d81856113d3565b935061144d8185602086016113e4565b61145681611417565b840191505092915050565b6000606082019050611476600083018661130d565b6114836020830185611020565b81810360408301526114958184611428565b9050949350505050565b60006060820190506114b46000830186610ea7565b81810360208301526114c68185611428565b905081810360408301526114da8184611428565b9050949350505050565b600080fd5b600080fd5b6114f782611417565b810181811067ffffffffffffffff82111715611516576115156112cc565b5b80604052505050565b6000611529610edf565b905061153582826114ee565b919050565b600067ffffffffffffffff821115611555576115546112cc565b5b61155e82611417565b9050602081019050919050565b600061157e6115798461153a565b61151f565b90508281526020810184848401111561159a576115996114e9565b5b6115a58482856113e4565b509392505050565b600082601f8301126115c2576115c16114e4565b5b81516115d284826020860161156b565b91505092915050565b6000602082840312156115f1576115f0610ee9565b5b600082015167ffffffffffffffff81111561160f5761160e610eee565b5b61161b848285016115ad565b91505092915050565b600060a082019050611639600083018861130d565b61164660208301876110fc565b6116536040830186611020565b61166060608301856110fc565b81810360808301526116728184611428565b90509695505050505050565b61168781611210565b82525050565b600060a0820190506116a2600083018861130d565b6116af6020830187611020565b6116bc60408301866110fc565b6116c9606083018561167e565b81810360808301526116db8184611428565b90509695505050505050565b60006080820190506116fc600083018761130d565b6117096020830186611020565b611716604083018561110b565b81810360608301526117288184611428565b90509594505050505056fea26469706673582212208adcfccee38c36cdc52088f7672a5a756dcd025a785fc127d5f491bcab02b6ab64736f6c634300080e0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061007d5760003560e01c8063844a5f5f1161005b578063844a5f5f146100d95780638c7f0959146100f757806391c05b0b14610115578063d58a8828146101315761007d565b80631cc8ca99146100825780632268cacb146100a15780634f514382146100bd575b600080fd5b61008a61014d565b604051610098929190610eb6565b60405180910390f35b6100bb60048036038101906100b69190610f31565b61019f565b005b6100d760048036038101906100d29190610f94565b6101dd565b005b6100e161027c565b6040516100ee9190610ff5565b60405180910390f35b6100ff6102a0565b60405161010c919061102f565b60405180910390f35b61012f600480360381019061012a919061104a565b6102a5565b005b61014b60048036038101906101469190610f31565b61044c565b005b60018060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16908060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905082565b6101da60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1630600084600161054990949392919063ffffffff16565b50565b600061021a60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff163060008660016105ab90949392919063ffffffff16565b506fffffffffffffffffffffffffffffffff169250505061027760008054906101000a900473ffffffffffffffffffffffffffffffffffffffff16600085858561026491906110a6565b600161066990949392919063ffffffff16565b505050565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600081565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd3330846040518463ffffffff1660e01b81526004016103029392919061111a565b6020604051808303816000875af1158015610321573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103459190611189565b5060006001800160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663899baaec60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff16306000866040518563ffffffff1660e01b81526004016103cc94939291906111b6565b6040805180830381865afa1580156103e8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061040c9190611258565b50905061044860008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1660008360016106cb909392919063ffffffff16565b5050565b600061048960008054906101000a900473ffffffffffffffffffffffffffffffffffffffff163060008560016105ab90949392919063ffffffff16565b506fffffffffffffffffffffffffffffffff16925050506104e760008054906101000a900473ffffffffffffffffffffffffffffffffffffffff166000846001856104d49190611298565b600161066990949392919063ffffffff16565b5050565b610544838383600067ffffffffffffffff81111561050c5761050b6112cc565b5b6040519080825280601f01601f19166020018201604052801561053e5781602001600182028036833780820191505090505b5061072b565b505050565b6105a48585858585600067ffffffffffffffff81111561056c5761056b6112cc565b5b6040519080825280601f01601f19166020018201604052801561059e5781602001600182028036833780820191505090505b506108e2565b5050505050565b6000806000808860010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16635b534051898989896040518563ffffffff1660e01b8152600401610614949392919061131c565b608060405180830381865afa158015610631573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106559190611361565b935093509350935095509550955095915050565b6106c48585858585600067ffffffffffffffff81111561068c5761068b6112cc565b5b6040519080825280601f01601f1916602001820160405280156106be5781602001600182028036833780820191505090505b50610a9f565b5050505050565b61072584848484600067ffffffffffffffff8111156106ed576106ec6112cc565b5b6040519080825280601f01601f19166020018201604052801561071f5781602001600182028036833780820191505090505b50610c5c565b50505050565b8360000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166339255d5b8560010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff168660010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d787840a8787600067ffffffffffffffff8111156107ed576107ec6112cc565b5b6040519080825280601f01601f19166020018201604052801561081f5781602001600182028036833780820191505090505b5060405160240161083293929190611461565b604051602081830303815290604052915060e01b6020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050846040518463ffffffff1660e01b81526004016108939392919061149f565b6000604051808303816000875af11580156108b2573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906108db91906115db565b5050505050565b8560000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166339255d5b8760010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff168860010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16632e5e74c689898989600067ffffffffffffffff8111156109a6576109a56112cc565b5b6040519080825280601f01601f1916602001820160405280156109d85781602001600182028036833780820191505090505b506040516024016109ed959493929190611624565b604051602081830303815290604052915060e01b6020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050846040518463ffffffff1660e01b8152600401610a4e9392919061149f565b6000604051808303816000875af1158015610a6d573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f82011682018060405250810190610a9691906115db565b50505050505050565b8560000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166339255d5b8760010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff168860010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663232d2b5889898989600067ffffffffffffffff811115610b6357610b626112cc565b5b6040519080825280601f01601f191660200182016040528015610b955781602001600182028036833780820191505090505b50604051602401610baa95949392919061168d565b604051602081830303815290604052915060e01b6020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050846040518463ffffffff1660e01b8152600401610c0b9392919061149f565b6000604051808303816000875af1158015610c2a573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f82011682018060405250810190610c5391906115db565b50505050505050565b8460000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166339255d5b8660010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff168760010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663b96731c2888888600067ffffffffffffffff811115610d1f57610d1e6112cc565b5b6040519080825280601f01601f191660200182016040528015610d515781602001600182028036833780820191505090505b50604051602401610d6594939291906116e7565b604051602081830303815290604052915060e01b6020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050846040518463ffffffff1660e01b8152600401610dc69392919061149f565b6000604051808303816000875af1158015610de5573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f82011682018060405250810190610e0e91906115db565b505050505050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b6000610e5b610e56610e5184610e16565b610e36565b610e16565b9050919050565b6000610e6d82610e40565b9050919050565b6000610e7f82610e62565b9050919050565b610e8f81610e74565b82525050565b6000610ea082610e62565b9050919050565b610eb081610e95565b82525050565b6000604082019050610ecb6000830185610e86565b610ed86020830184610ea7565b9392505050565b6000604051905090565b600080fd5b600080fd5b6000610efe82610e16565b9050919050565b610f0e81610ef3565b8114610f1957600080fd5b50565b600081359050610f2b81610f05565b92915050565b600060208284031215610f4757610f46610ee9565b5b6000610f5584828501610f1c565b91505092915050565b6000819050919050565b610f7181610f5e565b8114610f7c57600080fd5b50565b600081359050610f8e81610f68565b92915050565b60008060408385031215610fab57610faa610ee9565b5b6000610fb985828601610f1c565b9250506020610fca85828601610f7f565b9150509250929050565b6000610fdf82610e62565b9050919050565b610fef81610fd4565b82525050565b600060208201905061100a6000830184610fe6565b92915050565b600063ffffffff82169050919050565b61102981611010565b82525050565b60006020820190506110446000830184611020565b92915050565b6000602082840312156110605761105f610ee9565b5b600061106e84828501610f7f565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60006110b182610f5e565b91506110bc83610f5e565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff038211156110f1576110f0611077565b5b828201905092915050565b61110581610ef3565b82525050565b61111481610f5e565b82525050565b600060608201905061112f60008301866110fc565b61113c60208301856110fc565b611149604083018461110b565b949350505050565b60008115159050919050565b61116681611151565b811461117157600080fd5b50565b6000815190506111838161115d565b92915050565b60006020828403121561119f5761119e610ee9565b5b60006111ad84828501611174565b91505092915050565b60006080820190506111cb6000830187610fe6565b6111d860208301866110fc565b6111e56040830185611020565b6111f2606083018461110b565b95945050505050565b60008151905061120a81610f68565b92915050565b60006fffffffffffffffffffffffffffffffff82169050919050565b61123581611210565b811461124057600080fd5b50565b6000815190506112528161122c565b92915050565b6000806040838503121561126f5761126e610ee9565b5b600061127d858286016111fb565b925050602061128e85828601611243565b9150509250929050565b60006112a382610f5e565b91506112ae83610f5e565b9250828210156112c1576112c0611077565b5b828203905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600061130682610e62565b9050919050565b611316816112fb565b82525050565b6000608082019050611331600083018761130d565b61133e60208301866110fc565b61134b6040830185611020565b61135860608301846110fc565b95945050505050565b6000806000806080858703121561137b5761137a610ee9565b5b600061138987828801611174565b945050602061139a87828801611174565b93505060406113ab87828801611243565b92505060606113bc878288016111fb565b91505092959194509250565b600081519050919050565b600082825260208201905092915050565b60005b838110156114025780820151818401526020810190506113e7565b83811115611411576000848401525b50505050565b6000601f19601f8301169050919050565b6000611433826113c8565b61143d81856113d3565b935061144d8185602086016113e4565b61145681611417565b840191505092915050565b6000606082019050611476600083018661130d565b6114836020830185611020565b81810360408301526114958184611428565b9050949350505050565b60006060820190506114b46000830186610ea7565b81810360208301526114c68185611428565b905081810360408301526114da8184611428565b9050949350505050565b600080fd5b600080fd5b6114f782611417565b810181811067ffffffffffffffff82111715611516576115156112cc565b5b80604052505050565b6000611529610edf565b905061153582826114ee565b919050565b600067ffffffffffffffff821115611555576115546112cc565b5b61155e82611417565b9050602081019050919050565b600061157e6115798461153a565b61151f565b90508281526020810184848401111561159a576115996114e9565b5b6115a58482856113e4565b509392505050565b600082601f8301126115c2576115c16114e4565b5b81516115d284826020860161156b565b91505092915050565b6000602082840312156115f1576115f0610ee9565b5b600082015167ffffffffffffffff81111561160f5761160e610eee565b5b61161b848285016115ad565b91505092915050565b600060a082019050611639600083018861130d565b61164660208301876110fc565b6116536040830186611020565b61166060608301856110fc565b81810360808301526116728184611428565b90509695505050505050565b61168781611210565b82525050565b600060a0820190506116a2600083018861130d565b6116af6020830187611020565b6116bc60408301866110fc565b6116c9606083018561167e565b81810360808301526116db8184611428565b90509695505050505050565b60006080820190506116fc600083018761130d565b6117096020830186611020565b611716604083018561110b565b81810360608301526117288184611428565b90509594505050505056fea26469706673582212208adcfccee38c36cdc52088f7672a5a756dcd025a785fc127d5f491bcab02b6ab64736f6c634300080e0033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "deleteShares(address)": {
        "params": {
          "subscriber": "subscriber address whose subscription is to be deleted"
        }
      },
      "loseShare(address)": {
        "params": {
          "subscriber": "subscriber address whose units are to be decremented"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "deleteShares(address)": {
        "notice": "allows an account to delete its entire subscription this contract"
      },
      "distribute(uint256)": {
        "notice": "Takes the entire balance of the designated spreaderToken in the contract and distributes it out to unit holders w/ IDA"
      },
      "loseShare(address)": {
        "notice": "lets an account lose a single distribution unit"
      },
      "spreaderToken()": {
        "notice": "Super token to be distributed."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 11113,
        "contract": "contracts/NFTSpread.sol:NFTSpread",
        "label": "spreaderToken",
        "offset": 0,
        "slot": "0",
        "type": "t_contract(ISuperToken)9943"
      },
      {
        "astId": 11120,
        "contract": "contracts/NFTSpread.sol:NFTSpread",
        "label": "idaV1",
        "offset": 0,
        "slot": "1",
        "type": "t_struct(InitData)7088_storage"
      }
    ],
    "types": {
      "t_contract(IInstantDistributionAgreementV1)8963": {
        "encoding": "inplace",
        "label": "contract IInstantDistributionAgreementV1",
        "numberOfBytes": "20"
      },
      "t_contract(ISuperToken)9943": {
        "encoding": "inplace",
        "label": "contract ISuperToken",
        "numberOfBytes": "20"
      },
      "t_contract(ISuperfluid)10506": {
        "encoding": "inplace",
        "label": "contract ISuperfluid",
        "numberOfBytes": "20"
      },
      "t_struct(InitData)7088_storage": {
        "encoding": "inplace",
        "label": "struct IDAv1Library.InitData",
        "members": [
          {
            "astId": 7084,
            "contract": "contracts/NFTSpread.sol:NFTSpread",
            "label": "host",
            "offset": 0,
            "slot": "0",
            "type": "t_contract(ISuperfluid)10506"
          },
          {
            "astId": 7087,
            "contract": "contracts/NFTSpread.sol:NFTSpread",
            "label": "ida",
            "offset": 0,
            "slot": "1",
            "type": "t_contract(IInstantDistributionAgreementV1)8963"
          }
        ],
        "numberOfBytes": "64"
      }
    }
  }
}